{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Out-of-the-box outside-of-the-box thinking BraketLab is a pure Python-code for doing quantum theory in Jupyter Notebooks. BraketLab is being developed by Audun Skau Hansen (a.s.hansen@kjemi.uio.no) at the Department of Chemistry, Hylleraas Centre for Quantum Molecular Sciences, University of Oslo. Dependencies Numpy Sympy Matplotlib Numba Py3Dmol Installation Install the BraketLab-module using pip install braketlab from your terminal.","title":"Home"},{"location":"#out-of-the-box-outside-of-the-box-thinking","text":"BraketLab is a pure Python-code for doing quantum theory in Jupyter Notebooks. BraketLab is being developed by Audun Skau Hansen (a.s.hansen@kjemi.uio.no) at the Department of Chemistry, Hylleraas Centre for Quantum Molecular Sciences, University of Oslo.","title":"Out-of-the-box outside-of-the-box thinking"},{"location":"#dependencies","text":"Numpy Sympy Matplotlib Numba Py3Dmol","title":"Dependencies"},{"location":"#installation","text":"Install the BraketLab-module using pip install braketlab from your terminal.","title":"Installation"},{"location":"animate-reference/","text":"Animate module animated_system setup_plot ( self ) Initial drawing of the scatter plot. Source code in braketlab/animate.py def setup_plot ( self ): \"\"\"Initial drawing of the scatter plot.\"\"\" x , p = self . system . x , self . system . p w = self . system . w c1 , c2 , c3 = bb . colorscheme () . getcol ( np . random . uniform ( 0 , 1 , 3 )) self . bubbles = self . ax . plot ( x , p , \"-\" , color = ( 0 , 0 , 0 ), markersize = 1 , label = \"$ \\\\ vert \\Psi \\\\ vert^2$\" )[ 0 ] self . wf_imag = self . ax . plot ( x , w . imag , \"-\" , color = c1 ** .5 , markersize = 1 , label = \"Im($\\Psi$)\" )[ 0 ] self . wf_real = self . ax . plot ( x , w . real , \"-\" , color = c2 ** .5 , markersize = 1 , label = \"Re($\\Psi$)\" )[ 0 ] self . ax . legend () self . ax . axis ([ x [ 0 ], x [ - 1 ], - self . system . h , self . system . h ]) return self . bubbles , system advance ( self ) advance solution in time !!! note \"In order to make it optimal I used vectorized numpy,\" BUT the linear code is left commented out for clarity Source code in braketlab/animate.py def advance ( self ): \"\"\" advance solution in time note: In order to make it optimal I used vectorized numpy, BUT the linear code is left commented out for clarity \"\"\" w = self . psi ( self . x , t = self . t ) self . w = w self . p = ( w . conj () * w ) . real self . t += self . dt","title":"animate"},{"location":"animate-reference/#animate-module","text":"","title":"Animate module"},{"location":"animate-reference/#braketlab.animate.animated_system","text":"","title":"animated_system"},{"location":"animate-reference/#braketlab.animate.animated_system.setup_plot","text":"Initial drawing of the scatter plot. Source code in braketlab/animate.py def setup_plot ( self ): \"\"\"Initial drawing of the scatter plot.\"\"\" x , p = self . system . x , self . system . p w = self . system . w c1 , c2 , c3 = bb . colorscheme () . getcol ( np . random . uniform ( 0 , 1 , 3 )) self . bubbles = self . ax . plot ( x , p , \"-\" , color = ( 0 , 0 , 0 ), markersize = 1 , label = \"$ \\\\ vert \\Psi \\\\ vert^2$\" )[ 0 ] self . wf_imag = self . ax . plot ( x , w . imag , \"-\" , color = c1 ** .5 , markersize = 1 , label = \"Im($\\Psi$)\" )[ 0 ] self . wf_real = self . ax . plot ( x , w . real , \"-\" , color = c2 ** .5 , markersize = 1 , label = \"Re($\\Psi$)\" )[ 0 ] self . ax . legend () self . ax . axis ([ x [ 0 ], x [ - 1 ], - self . system . h , self . system . h ]) return self . bubbles ,","title":"setup_plot()"},{"location":"animate-reference/#braketlab.animate.system","text":"","title":"system"},{"location":"animate-reference/#braketlab.animate.system.advance","text":"advance solution in time !!! note \"In order to make it optimal I used vectorized numpy,\" BUT the linear code is left commented out for clarity Source code in braketlab/animate.py def advance ( self ): \"\"\" advance solution in time note: In order to make it optimal I used vectorized numpy, BUT the linear code is left commented out for clarity \"\"\" w = self . psi ( self . x , t = self . t ) self . w = w self . p = ( w . conj () * w ) . real self . t += self . dt","title":"advance()"},{"location":"basisbank-reference/","text":"Basisbank module get_gto ( a , l , m , position = array ([ 0 , 0 , 0 ])) Returns a ket containing the gaussian type primitive orbital with exponent a, and solid harmonic gaussian angular part defined by l and m located at position Source code in braketlab/basisbank.py def get_gto ( a , l , m , position = np . array ([ 0 , 0 , 0 ])): \"\"\" Returns a ket containing the gaussian type primitive orbital with exponent a, and solid harmonic gaussian angular part defined by l and m located at position \"\"\" psi = sh . get_Nao ( a , l , m ) vars = list ( psi . free_symbols ) symbols = bk . get_default_variables ( 0 , len ( vars )) for i in range ( len ( vars )): psi = psi . subs ( vars [ i ], symbols [ i ]) return bk . ket ( psi , name = \"\\chi_{ %i , %i }^{ %.2f }\" % ( l , m , a ), position = position ) get_harmonic_oscillator_function ( n , omega = 1 , position = 0 ) Returns a ket containing the harmonic oscillator energy eigenfunction with quantum number n located at position Source code in braketlab/basisbank.py def get_harmonic_oscillator_function ( n , omega = 1 , position = 0 ): \"\"\" Returns a ket containing the harmonic oscillator energy eigenfunction with quantum number n located at position \"\"\" return bk . ket ( ho . psi_ho ( n ), name = \" %i \" % n , energy = [ omega * ( .5 + n )], position = np . array ( position )) get_hydrogen_function ( n , l , m , position = array ([ 0 , 0 , 0 ])) Returns a ket containing the hydrogen eigenfunction with quantum numbers n,l,m located at position Source code in braketlab/basisbank.py def get_hydrogen_function ( n , l , m , position = np . array ([ 0 , 0 , 0 ])): \"\"\" Returns a ket containing the hydrogen eigenfunction with quantum numbers n,l,m located at position \"\"\" psi = hy . hydrogen_function ( n , l , m ) #vars = list(psi.free_symbols) vars = bk . get_ordered_symbols ( psi ) symbols = bk . get_default_variables ( 0 , len ( vars )) for i in range ( len ( vars )): psi = psi . subs ( vars [ i ], symbols [ i ]) return bk . ket ( psi , name = \" %i , %i , %i \" % ( n , l , m ), position = position ) get_sto ( a , w , l , m , position = array ([ 0 , 0 , 0 ])) Returns a ket containing the slater type orbital with exponent a, weight w, and solid harmonic gaussian angular part defined by l and m located at position Source code in braketlab/basisbank.py def get_sto ( a , w , l , m , position = np . array ([ 0 , 0 , 0 ])): \"\"\" Returns a ket containing the slater type orbital with exponent a, weight w, and solid harmonic gaussian angular part defined by l and m located at position \"\"\" psi = sh . get_sto ( a , w , l , m ) vars = list ( psi . free_symbols ) symbols = bk . get_default_variables ( 0 , len ( vars )) for i in range ( len ( vars )): psi = psi . subs ( vars [ i ], symbols [ i ]) return bk . ket ( psi , name = \"\\chi_{ %i , %i }^{ %.2f }\" % ( l , m , a ), position = position )","title":"basisbank"},{"location":"basisbank-reference/#basisbank-module","text":"","title":"Basisbank module"},{"location":"basisbank-reference/#braketlab.basisbank.get_gto","text":"Returns a ket containing the gaussian type primitive orbital with exponent a, and solid harmonic gaussian angular part defined by l and m located at position Source code in braketlab/basisbank.py def get_gto ( a , l , m , position = np . array ([ 0 , 0 , 0 ])): \"\"\" Returns a ket containing the gaussian type primitive orbital with exponent a, and solid harmonic gaussian angular part defined by l and m located at position \"\"\" psi = sh . get_Nao ( a , l , m ) vars = list ( psi . free_symbols ) symbols = bk . get_default_variables ( 0 , len ( vars )) for i in range ( len ( vars )): psi = psi . subs ( vars [ i ], symbols [ i ]) return bk . ket ( psi , name = \"\\chi_{ %i , %i }^{ %.2f }\" % ( l , m , a ), position = position )","title":"get_gto()"},{"location":"basisbank-reference/#braketlab.basisbank.get_harmonic_oscillator_function","text":"Returns a ket containing the harmonic oscillator energy eigenfunction with quantum number n located at position Source code in braketlab/basisbank.py def get_harmonic_oscillator_function ( n , omega = 1 , position = 0 ): \"\"\" Returns a ket containing the harmonic oscillator energy eigenfunction with quantum number n located at position \"\"\" return bk . ket ( ho . psi_ho ( n ), name = \" %i \" % n , energy = [ omega * ( .5 + n )], position = np . array ( position ))","title":"get_harmonic_oscillator_function()"},{"location":"basisbank-reference/#braketlab.basisbank.get_hydrogen_function","text":"Returns a ket containing the hydrogen eigenfunction with quantum numbers n,l,m located at position Source code in braketlab/basisbank.py def get_hydrogen_function ( n , l , m , position = np . array ([ 0 , 0 , 0 ])): \"\"\" Returns a ket containing the hydrogen eigenfunction with quantum numbers n,l,m located at position \"\"\" psi = hy . hydrogen_function ( n , l , m ) #vars = list(psi.free_symbols) vars = bk . get_ordered_symbols ( psi ) symbols = bk . get_default_variables ( 0 , len ( vars )) for i in range ( len ( vars )): psi = psi . subs ( vars [ i ], symbols [ i ]) return bk . ket ( psi , name = \" %i , %i , %i \" % ( n , l , m ), position = position )","title":"get_hydrogen_function()"},{"location":"basisbank-reference/#braketlab.basisbank.get_sto","text":"Returns a ket containing the slater type orbital with exponent a, weight w, and solid harmonic gaussian angular part defined by l and m located at position Source code in braketlab/basisbank.py def get_sto ( a , w , l , m , position = np . array ([ 0 , 0 , 0 ])): \"\"\" Returns a ket containing the slater type orbital with exponent a, weight w, and solid harmonic gaussian angular part defined by l and m located at position \"\"\" psi = sh . get_sto ( a , w , l , m ) vars = list ( psi . free_symbols ) symbols = bk . get_default_variables ( 0 , len ( vars )) for i in range ( len ( vars )): psi = psi . subs ( vars [ i ], symbols [ i ]) return bk . ket ( psi , name = \"\\chi_{ %i , %i }^{ %.2f }\" % ( l , m , a ), position = position )","title":"get_sto()"},{"location":"braketlab-reference/","text":"Braketlab module basisfunction A general class for a basis function in \\(\\mathbb{R}^n\\) Keyword arguments: Argument Description sympy_expression A sympy expression position assumed center of basis function (defaults to \\(\\mathbf{0}\\) ) name (unused) domain if None, the domain is R^n, if [ [x0, x1], [ y0, y1], ... ] , the domain is finite Methods Method Description normalize Perform numerical normalization of self estimate_decay Estimate decay of self, used for importance sampling (currently inactive) get_domain(other) Returns the intersecting domain of two basis functions Example usage: x = sympy.Symbol(\"x\") x2 = basisfunction(x**2) x2.normalize() __add__ ( self , other ) special Returns a basisfunction \\(\\chi_{a+b}(\\mathbf{r})\\) , where \\(\\chi_{a+b}(\\mathbf{r}) = \\chi_a(\\mathbf{r}) + \\chi_b(\\mathbf{r})\\) Source code in braketlab/braketlab.py def __add__ ( self , other ): \"\"\" Returns a basisfunction $\\chi_{a+b}(\\mathbf{r})$, where $\\chi_{a+b}(\\mathbf{r}) = \\chi_a(\\mathbf{r}) + \\chi_b(\\mathbf{r})$ \"\"\" return basisfunction ( self . ket_sympy_expression + other . ket_sympy_expression , position = .5 * ( self . position + other . position ), domain = self . get_domain ( other )) __call__ ( self , * r ) special Evaluate function in coordinates *r (arbitrary dimensions). Returns The basisfunction \\(\\chi\\) evaluated in the coordinates provided in the array(s) *r : \\(\\int_{\\mathbb{R}^n} \\delta(\\mathbf{r} - \\mathbf{r'}) \\chi(\\mathbf{r'}) d\\mathbf{r'}\\) Source code in braketlab/braketlab.py def __call__ ( self , * r ): \"\"\" Evaluate function in coordinates ```*r``` (arbitrary dimensions). ## Returns The basisfunction $\\chi$ evaluated in the coordinates provided in the array(s) ```*r```: $\\int_{\\mathbb{R}^n} \\delta(\\mathbf{r} - \\mathbf{r'}) \\chi(\\mathbf{r'}) d\\mathbf{r'}$ \"\"\" return self . normalization * self . ket_numeric_expression ( * r ) __mul__ ( self , other ) special Returns a basisfunction \\(\\chi_{a*b}(\\mathbf{r})\\) , where \\(\\chi_{a*b}(\\mathbf{r}) = \\chi_a(\\mathbf{r}) \\chi_b(\\mathbf{r})\\) Source code in braketlab/braketlab.py def __mul__ ( self , other ): \"\"\" Returns a basisfunction $\\chi_{a*b}(\\mathbf{r})$, where $\\chi_{a*b}(\\mathbf{r}) = \\chi_a(\\mathbf{r}) \\chi_b(\\mathbf{r})$ \"\"\" return basisfunction ( self . ket_sympy_expression * other . ket_sympy_expression , position = .5 * ( self . position + other . position ), domain = self . get_domain ( other ), name = self . __name__ + other . __name__ ) __sub__ ( self , other ) special Returns a basisfunction \\(\\chi_{a-b}(\\mathbf{r})\\) , where \\(\\chi_{a-b}(\\mathbf{r}) = \\chi_a(\\mathbf{r}) - \\chi_b(\\mathbf{r})\\) Source code in braketlab/braketlab.py def __sub__ ( self , other ): \"\"\" Returns a basisfunction $\\chi_{a-b}(\\mathbf{r})$, where $\\chi_{a-b}(\\mathbf{r}) = \\chi_a(\\mathbf{r}) - \\chi_b(\\mathbf{r})$ \"\"\" return basisfunction ( self . ket_sympy_expression - other . ket_sympy_expression , position = .5 * ( self . position + other . position ), domain = self . get_domain ( other )) normalize ( self , domain = None ) Set normalization factor \\(N\\) of self ( \\(\\chi\\) ) so that \\(\\langle \\chi \\vert \\chi \\rangle = 1\\) . Source code in braketlab/braketlab.py def normalize ( self , domain = None ): \"\"\" Set normalization factor $N$ of self ($\\chi$) so that $\\langle \\chi \\\\vert \\chi \\\\rangle = 1$. \"\"\" s_12 = inner_product ( self , self ) self . normalization = s_12 **- .5 ket A class for vectors defined on general vector spaces Author: Audun Skau Hansen (a.s.hansen@kjemi.uio.no) Keyword arguments: Method Description generic_input if list or numpy.ndarray: if basis is None, returns a cartesian vector else, assumes input to contain coefficients. If sympy expression, returns ket([1], basis = [basisfunction(generic_input)]) name a string, used for labelling and plotting, visual aids basis a list of basisfunctions position assumed centre of function \\(\\langle \\vert \\hat{\\mathbf{r}} \\vert \\rangle\\) . energy if this is an eigenstate of a Hamiltonian, it's eigenvalue may be fixed at initialization Operations For kets B and A and scalar c Operation Description A + B addition A - C subtraction A * c scalar multiplication A / c division by a scalar A * B pointwise product A.bra*B inner product A.bra@B inner product A @ B cartesian product A(x) \\(\\int_R^n \\delta(x - x') f(x') dx'\\) evaluate function at x __init__ ( self , generic_input , name = '' , basis = None , position = None , energy = None ) special Initialization of a ket Source code in braketlab/braketlab.py def __init__ ( self , generic_input , name = \"\" , basis = None , position = None , energy = None ): \"\"\" ## Initialization of a ket \"\"\" self . position = position if type ( generic_input ) in [ np . ndarray , list ]: self . coefficients = list ( generic_input ) self . basis = [ i for i in np . eye ( len ( self . coefficients ))] if basis is not None : self . basis = basis else : # assume sympy expression if position is None : position = np . zeros ( len ( generic_input . free_symbols ), dtype = float ) self . coefficients = [ 1.0 ] self . basis = [ basisfunction ( generic_input , position = position )] self . ket_sympy_expression = self . get_ket_sympy_expression () self . bra_sympy_expression = self . get_bra_sympy_expression () if energy is not None : self . energy = energy else : self . energy = [ 0 for i in range ( len ( self . basis ))] self . __name__ = name self . bra_state = False self . a = None __matmul__ ( self , other ) special Inner- and Cartesian products Source code in braketlab/braketlab.py def __matmul__ ( self , other ): \"\"\" Inner- and Cartesian products \"\"\" if type ( other ) in [ float , int ]: return self * other if type ( other ) is ket : if self . bra_state : # Compute inner product: < self | other > metric = np . zeros (( len ( self . basis ), len ( other . basis )), dtype = np . complex ) for i in range ( len ( self . basis )): for j in range ( len ( other . basis )): if type ( self . basis [ i ]) is np . ndarray and type ( other . basis [ j ]) is np . ndarray : metric [ i , j ] = np . dot ( self . basis [ i ], other . basis [ j ]) else : if type ( self . basis [ i ]) is basisfunction : if type ( other . basis [ j ]) is basisfunction : # (basisfunction | basisfunction) metric [ i , j ] = inner_product ( self . basis [ i ], other . basis [ j ]) if other . basis [ j ] is ket : # (basisfunction | ket ) metric [ i , j ] = ket ([ 1.0 ], basis = [ self . basis [ i ]]) . bra @other . basis [ j ] else : if type ( other . basis [ j ]) is basisfunction : # ( ket | basisfunction ) metric [ i , j ] = self . basis [ i ] . bra @ket ([ 1.0 ], basis = [ other . basis [ j ]]) else : # ( ket | ket ) metric [ i , j ] = self . basis [ i ] . bra @other . basis [ j ] if np . linalg . norm ( metric . imag ) <= 1e-10 : metric = metric . real return np . array ( self . coefficients ) . T . dot ( metric . dot ( np . array ( other . coefficients ))) else : if type ( other ) is ket : if other . bra_state : return outerprod ( self , other ) else : new_coefficients = [] new_basis = [] variable_identities = [] #for potential two-body interactions for i in range ( len ( self . basis )): for j in range ( len ( other . basis )): #bij, sep = split_variables(self.basis[i].ket_sympy_expression, other.basis[j].ket_sympy_expression) bij , sep = relabel_direct ( self . basis [ i ] . ket_sympy_expression , other . basis [ j ] . ket_sympy_expression ) #bij = ket(bij) bij = basisfunction ( bij ) #, position = other.basis[j].position) bij . position = np . append ( self . basis [ i ] . position , other . basis [ j ] . position ) new_basis . append ( bij ) new_coefficients . append ( self . coefficients [ i ] * other . coefficients [ j ]) variable_identities . append ( sep ) ret = ket ( new_coefficients , basis = new_basis ) ret . flatten () ret . __name__ = self . __name__ + other . __name__ ret . variable_identities = variable_identities return ret flatten ( self ) Remove redundancies in the expansion of self Source code in braketlab/braketlab.py def flatten ( self ): \"\"\" Remove redundancies in the expansion of self \"\"\" new_coefficients = [] new_basis = [] new_energies = [] found = [] for i in range ( len ( self . basis )): if i not in found : new_coefficients . append ( self . coefficients [ i ]) new_basis . append ( self . basis [ i ]) new_energies . append ( self . energy [ i ]) for j in range ( i + 1 , len ( self . basis )): if type ( self . basis [ i ]) is np . ndarray : if type ( self . basis [ j ]) is np . ndarray : if np . all ( self . basis [ i ] == self . basis [ j ]): new_coefficients [ i ] += self . coefficients [ j ] found . append ( j ) else : if self . basis [ i ] . ket_sympy_expression == self . basis [ j ] . ket_sympy_expression : if np . all ( self . basis [ i ] . position == self . basis [ j ] . position ): new_coefficients [ i ] += self . coefficients [ j ] found . append ( j ) self . basis = new_basis self . coefficients = new_coefficients self . energy = new_energies measure ( self , observable = None , repetitions = 1 ) Make a mesaurement of the observable (hermitian operator) Measures by default the continuous distribution as defined by self.bra*self Source code in braketlab/braketlab.py def measure ( self , observable = None , repetitions = 1 ): \"\"\" Make a mesaurement of the observable (hermitian operator) Measures by default the continuous distribution as defined by self.bra*self \"\"\" if observable is None : # Measure position P = self . get_bra_sympy_expression () * self . get_ket_sympy_expression () symbols = get_ordered_symbols ( P ) P = sp . lambdify ( symbols , P , \"numpy\" ) nd = len ( symbols ) sig = .1 #variance of initial distribution r = np . random . multivariate_normal ( np . zeros ( nd ), sig * np . eye ( nd ), repetitions ) # Metropolis-Hastings for i in range ( 1000 ): dr = np . random . multivariate_normal ( np . zeros ( nd ), 0.01 * sig * np . eye ( nd ), repetitions ) accept = P ( r + dr ) / P ( r ) > np . random . uniform ( 0 , 1 , nd ) r [ accept ] += dr [ accept ] return r else : #assert(False), \"Arbitrary measurements not yet implemented\" # get coefficients P = np . zeros ( len ( observable . eigenstates ), dtype = float ) for i in range ( len ( observable . eigenstates )): P [ i ] = ( observable . eigenstates [ i ] . bra @self ) ** 2 distribution = discrete_metropolis_hastings ( P , n_samples = repetitions ) return observable . eigenvalues [ distribution ] operator Parent class for operators operator_expression A class for algebraic operator manipulations instantiate with a list of list of operators Example operator([[a, b], [c,d]], [1,2]]) = 1*ab + 2*cd __add__ ( self , other ) special Operator addition Source code in braketlab/braketlab.py def __add__ ( self , other ): \"\"\" # Operator addition \"\"\" new_ops = self . ops + other . ops new_coeffs = self . coefficients + other . coefficients return operator_expression ( new_ops , new_coeffs ) . flatten () __mul__ ( self , other ) special Operator multiplication Source code in braketlab/braketlab.py def __mul__ ( self , other ): \"\"\" # Operator multiplication \"\"\" if type ( other ) is operator : new_ops = [] for i in self . ops : for j in other . ops : new_ops . append ( i + j ) return operator ( new_ops ) . flatten () else : return self . apply ( other ) __sub__ ( self , other ) special Operator subtraction Source code in braketlab/braketlab.py def __sub__ ( self , other ): \"\"\" # Operator subtraction \"\"\" new_ops = self . ops + other . ops new_coeffs = self . coefficients + [ - 1 * i for i in other . coefficients ] return operator_expression ( new_ops , new_coeffs ) . flatten () apply ( self , other_ket ) Apply operator to ket $\\hat{\\Omega} ert a angle = ert a' angle $ Returns A new ket Source code in braketlab/braketlab.py def apply ( self , other_ket ): \"\"\" # Apply operator to ket $\\hat{\\Omega} \\vert a \\rangle = \\vert a' \\rangle $ ## Returns A new ket \"\"\" ret = 0 for i in range ( len ( self . ops )): ret_term = other_ket * 1 for j in range ( len ( self . ops [ i ])): ret_term = self . ops [ i ][ - j ] * ret_term if i == 0 : ret = ret_term else : ret = ret + ret_term return ret flatten ( self ) Remove redundant terms Source code in braketlab/braketlab.py def flatten ( self ): \"\"\" # Remove redundant terms \"\"\" new_ops = [] new_coeffs = [] found = [] for i in range ( len ( self . ops )): if i not in found : new_ops . append ( self . ops [ i ]) new_coeffs . append ( 1 ) for j in range ( i + 1 , len ( self . ops )): if self . ops [ i ] == self . ops [ j ]: print ( \"flatten:\" , i , j , self . ops [ i ], self . ops [ j ]) #self.coefficients[i] += 1 found . append ( j ) new_coeffs [ - 1 ] += self . coefficients [ j ] return operator_expression ( new_ops , new_coeffs ) apply_twobody_operator ( sympy_expression , p1 , p2 ) Generate the sympy expression sympy_expression / | x_p1 - x_p2 | Source code in braketlab/braketlab.py def apply_twobody_operator ( sympy_expression , p1 , p2 ): \"\"\" Generate the sympy expression sympy_expression / | x_p1 - x_p2 | \"\"\" return sympy_expression / get_twobody_denominator ( sympy_expression , p1 , p2 ) compose_basis ( p ) generate a list of basis functions corresponding to the AO-basis (same ordering and so on) Source code in braketlab/braketlab.py def compose_basis ( p ): \"\"\" generate a list of basis functions corresponding to the AO-basis (same ordering and so on) \"\"\" basis = [] for charge in np . arange ( p . charges . shape [ 0 ]): atomic_number = p . charges [ charge ] atom = np . argwhere ( p . atomic_numbers == atomic_number )[ 0 , 0 ] #index of basis function pos = p . atoms [ charge ] for shell in np . arange ( len ( p . basis_set [ atom ])): for contracted in np . arange ( len ( p . basis_set [ atom ][ shell ])): W = np . array ( p . basis_set [ atom ][ shell ][ contracted ]) w = W [:, 1 ] a = W [:, 0 ] if shell == 1 : for m in np . array ([ 1 , - 1 , 0 ]): basis . append ( basis_function ([ shell , m , a , w ], basis_type = \"cgto\" , domain = [[ - 8 , 8 ],[ - 8 , 8 ],[ - 8 , 8 ]], position = pos )) else : for m in np . arange ( - shell , shell + 1 ): basis . append ( basis_function ([ shell , m , a , w ], basis_type = \"cgto\" , domain = [[ - 8 , 8 ],[ - 8 , 8 ],[ - 8 , 8 ]], position = pos )) return basis construct_basis ( p ) Build basis from prism object Source code in braketlab/braketlab.py def construct_basis ( p ): \"\"\" Build basis from prism object \"\"\" basis = [] for atom , pos in zip ( p . basis_set , p . atoms ): for shell in atom : for contracted in shell : contracted = np . array ( contracted ) l = int ( contracted [ 0 , 2 ]) a = contracted [:, 0 ] w = contracted [:, 1 ] for m in range ( - l , l + 1 ): bf = w [ 0 ] * get_solid_harmonic_gaussian ( a [ 0 ], l , m , position = [ 0 , 0 , 0 ]) for weights in range ( 1 , len ( w )): bf += w [ i ] * get_solid_harmonic_gaussian ( a [ i ], l , m , position = [ 0 , 0 , 0 ]) #get_solid_harmonic_gaussian(a,l,m, position = [0,0,0]) basis . append ( bf ) return basis discrete_metropolis_hastings ( P , n_samples = 10000 , n_iterations = 10000 , stepsize = None ) Perform a random walk in the discrete distribution P (array) Source code in braketlab/braketlab.py def discrete_metropolis_hastings ( P , n_samples = 10000 , n_iterations = 10000 , stepsize = None ): \"\"\" Perform a random walk in the discrete distribution P (array) \"\"\" #ensure normality n = np . sum ( P ) Px = interp1d ( np . linspace ( 0 , 1 , len ( P )), P / n ) x = np . random . uniform ( 0 , 1 , n_samples ) if stepsize is None : #set stepsize proportional to discretization stepsize = .5 * len ( P ) **- 1 print ( \"stepsize:\" , stepsize ) for i in range ( n_iterations ): dx = np . random . normal ( 0 , stepsize , n_samples ) xdx = x + dx # periodic boundaries xdx [ xdx < 0 ] += 1 xdx [ xdx > 1 ] -= 1 accept = Px ( xdx ) / Px ( x ) > np . random . uniform ( 0 , 1 , n_samples ) x [ accept ] = xdx [ accept ] return np . array ( x * len ( P ), dtype = int ) eri_mci ( phi_p , phi_q , phi_r , phi_s , pp = array ([ 0 , 0 , 0 ]), pq = array ([ 0 , 0 , 0 ]), pr = array ([ 0 , 0 , 0 ]), ps = array ([ 0 , 0 , 0 ]), N_samples = 1000000 , sigma = 0.5 , Pr = array ([ 0 , 0 , 0 ]), Qr = array ([ 0 , 0 , 0 ]), zeta = 1 , eta = 1 , auto = False , control_variate =< function < lambda > at 0x7fe59ae02c20 > ) Electron repulsion integral estimate using zero-variance Monte Carlo Source code in braketlab/braketlab.py def eri_mci ( phi_p , phi_q , phi_r , phi_s , pp = np . array ([ 0 , 0 , 0 ]), pq = np . array ([ 0 , 0 , 0 ]), pr = np . array ([ 0 , 0 , 0 ]), ps = np . array ([ 0 , 0 , 0 ]), N_samples = 1000000 , sigma = .5 , Pr = np . array ([ 0 , 0 , 0 ]), Qr = np . array ([ 0 , 0 , 0 ]), zeta = 1 , eta = 1 , auto = False , control_variate = lambda x1 , x2 , x3 , x4 , x5 , x6 : 0 ): \"\"\" Electron repulsion integral estimate using zero-variance Monte Carlo \"\"\" x = np . random . multivariate_normal ([ 0 , 0 , 0 , 0 , 0 , 0 ], np . eye ( 6 ) * sigma , N_samples ) P = multivariate_normal ( mean = [ 0 , 0 , 0 , 0 , 0 , 0 ], cov = np . eye ( 6 ) * sigma ) . pdf if auto : # estimate mean and variance of orbitals X , Y , Z = np . random . uniform ( - 5 , 5 ,( 3 , 10000 )) P_1 = phi_p ( X , Y , Z ) * phi_q ( X , Y , Z ) P_2 = phi_r ( X , Y , Z ) * phi_s ( X , Y , Z ) Pr [ 0 ] = np . mean ( P_1 ** 2 * X ) Pr [ 1 ] = np . mean ( P_1 ** 2 * Y ) Pr [ 2 ] = np . mean ( P_1 ** 2 * Z ) Qr [ 0 ] = np . mean ( P_2 ** 2 * X ) Qr [ 1 ] = np . mean ( P_2 ** 2 * Y ) Qr [ 2 ] = np . mean ( P_2 ** 2 * Z ) integrand = lambda * R , \\ phi_p = phi_p , \\ phi_q = phi_q , \\ phi_r = phi_r , \\ phi_s = phi_s , \\ rp = pp , rq = pq , rr = pq , rs = ps : \\ phi_p ( R [ 0 ] - rp [ 0 ], R [ 1 ] - rp [ 1 ], R [ 2 ] - rp [ 2 ]) * \\ phi_q ( R [ 0 ] - rq [ 0 ], R [ 1 ] - rq [ 1 ], R [ 2 ] - rq [ 2 ]) * \\ phi_r ( R [ 3 ] - rr [ 0 ], R [ 4 ] - rr [ 1 ], R [ 5 ] - rr [ 2 ]) * \\ phi_s ( R [ 3 ] - rs [ 0 ], R [ 4 ] - rs [ 1 ], R [ 5 ] - rs [ 2 ]) if control_variate == \"spline\" : control_variate , I0 , t = get_control_variate ( integrand , loc = np . array ([ 0 , 0 , 0 , 0 , 0 , 0 ]), a = .6 , tmin = 1e-5 , extent = 6 , grid = 11 ) u1 = x [:, : 3 ] * zeta **- .5 + Pr [:] u2 = x [:, 3 :] * eta **- .5 + Qr [:] r12 = np . sqrt ( np . sum ( ( u1 - u2 ) ** 2 , axis = 1 )) return np . mean (( phi_p ( u1 [:, 0 ] - pp [ 0 ], u1 [:, 1 ] - pp [ 1 ], u1 [:, 2 ] - pp [ 2 ]) * phi_q ( u1 [:, 0 ] - pq [ 0 ], u1 [:, 1 ] - pq [ 1 ], u1 [:, 2 ] - pq [ 2 ]) * phi_r ( u2 [:, 0 ] - pr [ 0 ], u2 [:, 1 ] - pr [ 1 ], u2 [:, 2 ] - pr [ 2 ]) * phi_s ( u2 [:, 0 ] - ps [ 0 ], u2 [:, 1 ] - ps [ 1 ], u2 [:, 2 ] - ps [ 2 ]) - control_variate ( u1 [:, 0 ], u1 [:, 1 ], u1 [:, 2 ], u2 [:, 0 ], u2 [:, 1 ], u2 [:, 2 ]) ) / ( P ( x ) * r12 ) ) * ( zeta * eta ) **- 1.5 get_control_variate ( integrand , loc , a = 0.6 , tmin = 1e-05 , extent = 6 , grid = 101 ) Generate an nd interpolated control variate returns RegularGridInterpolator, definite integral on mesh, mesh points Keyword arguments integrand -- an evaluateable function loc -- position offset for integrand a -- grid density decay, tmin -- extent -- grid -- number of grid points Source code in braketlab/braketlab.py def get_control_variate ( integrand , loc , a = .6 , tmin = 1e-5 , extent = 6 , grid = 101 ): \"\"\" Generate an nd interpolated control variate returns RegularGridInterpolator, definite integral on mesh, mesh points Keyword arguments integrand -- an evaluateable function loc -- position offset for integrand a -- grid density decay, tmin -- extent -- grid -- number of grid points \"\"\" t = np . linspace ( tmin , extent ** a , grid ) ** ( a **- 1 ) t = np . append ( - t [:: - 1 ], t ) R_ = np . ones (( loc . shape [ 0 ], t . shape [ 0 ])) * t [ None ,:] R = np . meshgrid ( * ( R_ - loc [:, None ]), indexing = 'ij' , sparse = True ) data = integrand ( * R ) # Integrate I0 = rgrid_integrate_nd ( t , data ) #return RegularGridInterpolator(R_, data, bounds_error = False, fill_value = 0), I0, t return RegularGridInterpolator ( R_ - loc [:, None ], data , bounds_error = False , fill_value = 0 ), I0 , t get_twobody_denominator ( sympy_expression , p1 , p2 ) For a sympy_expression of arbitrary dimensionality, generate the coulomb operator 1/sqrt( r_{p1, p2} ) assuming that the symbols are of the form \"x_{pn, x_i}\" where x_i is the cartesian vector component Source code in braketlab/braketlab.py def get_twobody_denominator ( sympy_expression , p1 , p2 ): \"\"\" For a sympy_expression of arbitrary dimensionality, generate the coulomb operator 1/sqrt( r_{p1, p2} ) assuming that the symbols are of the form \"x_{pn, x_i}\" where x_i is the cartesian vector component \"\"\" mex , n = map_expression ( sympy_expression , p1 , p2 ) denom = 0 for i in range ( n ): denom += ( mex [ 0 , i ] - mex [ 1 , i ]) ** 2 return sp . sqrt ( denom ) inner_product ( b1 , b2 , operator = None , n_samples = 1000000 , grid = 101 , sigma = None ) Computes the inner product < b1 | b2 >, where bn are instances of basisfunction b1, b2 -- basisfunction objects operator -- obsolete n_samples -- number of Monte Carlo samples grid -- number of grid-points in every direction for the spline control variate The inner product as a float Source code in braketlab/braketlab.py @lru_cache ( maxsize = 100 ) def inner_product ( b1 , b2 , operator = None , n_samples = int ( 1e6 ), grid = 101 , sigma = None ): \"\"\" Computes the inner product < b1 | b2 >, where bn are instances of basisfunction Keyword arguments: b1, b2 -- basisfunction objects operator -- obsolete n_samples -- number of Monte Carlo samples grid -- number of grid-points in every direction for the spline control variate Returns: The inner product as a float \"\"\" ri = b1 . position * 0 rj = b2 . position * 0 integrand = lambda * R , \\ f1 = b1 . bra_numeric_expression , \\ f2 = b2 . ket_numeric_expression , \\ ri = ri , rj = rj : \\ f1 ( * np . array ([ R [ i ] - ri [ i ] for i in range ( len ( ri ))])) * f2 ( * np . array ([ R [ i ] - rj [ i ] for i in range ( len ( rj ))])) #f1(*np.array([R[i] - ri[i] for i in range(len(ri))]))*f2(*np.array([R[i] - rj[i] for i in range(len(rj))])) variables_b1 = b1 . bra_sympy_expression . free_symbols variables_b2 = b2 . ket_sympy_expression . free_symbols if len ( variables_b1 ) == 1 and len ( variables_b2 ) == 1 : return integrate . quad ( integrand , - 10 , 10 )[ 0 ] else : ai , aj = b1 . decay , b2 . decay ri , rj = b1 . position , b2 . position R = ( ai * ri + aj * rj ) / ( ai + aj ) if sigma is None : sigma = .5 * ( ai + aj ) #print(\"R, sigma:\", R, sigma) return onebody ( integrand , np . ones ( len ( R )) * sigma , R , n_samples ) #, control_variate = \"spline\", grid = grid) map_expression ( sympy_expression , x1 = 0 , x2 = 1 ) Map out the free symbols of sympy_expressions in order to determine z[p, x] where p = [0,1] is particle x1 and x2, while x is their cartesian component Source code in braketlab/braketlab.py def map_expression ( sympy_expression , x1 = 0 , x2 = 1 ): \"\"\" Map out the free symbols of sympy_expressions in order to determine z[p, x] where p = [0,1] is particle x1 and x2, while x is their cartesian component \"\"\" map_ = { x1 : 0 , x2 : 1 } s = sympy_expression . free_symbols n = int ( len ( s ) / 2 ) z = np . zeros (( 2 , n ), dtype = object ) for i in s : j , k = parse_symbol ( i ) #particle, coordinate z [ map_ [ j ], k ] = i return z , n metropolis_hastings ( f , N , x0 , a ) Metropolis-Hastings random walk in the function f Source code in braketlab/braketlab.py def metropolis_hastings ( f , N , x0 , a ): \"\"\" Metropolis-Hastings random walk in the function f \"\"\" x = np . random . multivariate_normal ( x0 , a , N ) for i in range ( 1000 ): dx = np . random . multivariate_normal ( x0 , a * 0.01 , N ) accept = f ( x + dx ) / f ( x ) > np . random . uniform ( 0 , 1 , N ) x [ accept ] += dx [ accept ] return x onebody ( integrand , sigma , loc , n_samples , control_variate =< function < lambda > at 0x7fe59ae02b00 > , grid = 101 , I0 = 0 ) Monte Carlo (MC) estimate of integral integrand -- evaluatable function sigma -- standard deviation of normal distribution used for importance sampling loc -- centre used for control variate and importance sampling n_sampes -- number of MC-samples control_variate -- evaluatable function grid -- sampling density of spline control variate I0 -- analytical integral of control variate Estimated integral (float) Source code in braketlab/braketlab.py def onebody ( integrand , sigma , loc , n_samples , control_variate = lambda * r : 0 , grid = 101 , I0 = 0 ): \"\"\" Monte Carlo (MC) estimate of integral Keyword arguments: integrand -- evaluatable function sigma -- standard deviation of normal distribution used for importance sampling loc -- centre used for control variate and importance sampling n_sampes -- number of MC-samples control_variate -- evaluatable function grid -- sampling density of spline control variate I0 -- analytical integral of control variate returns: Estimated integral (float) \"\"\" if control_variate == \"spline\" : control_variate , I0 , t = get_control_variate ( integrand , loc , a = .6 , tmin = 1e-5 , extent = 6 , grid = grid ) #R = np.random.multivariate_normal(loc, np.eye(len(loc))*sigma, n_samples) #R = np.random.Generator.multivariate_normal(loc, np.eye(len(loc))*sigma, size=n_samples) R = np . random . default_rng () . multivariate_normal ( loc , np . eye ( len ( loc )) * sigma , n_samples ) P = multivariate_normal ( mean = loc , cov = np . eye ( len ( loc )) * sigma ) . pdf ( R ) return I0 + np . mean (( integrand ( * R . T ) - control_variate ( R )) * P **- 1 ) parse_symbol ( x ) Parse a symbol of the form x_{i;j} Return a list [i,j] Source code in braketlab/braketlab.py def parse_symbol ( x ): \"\"\" Parse a symbol of the form x_{i;j} Return a list [i,j] \"\"\" strspl = str ( x ) . split ( \"{\" )[ 1 ] . split ( \"}\" )[ 0 ] . split ( \";\" ) return [ int ( i ) for i in strspl ] rgrid_integrate_3d ( points , values ) regular grid integration, 3D Source code in braketlab/braketlab.py def rgrid_integrate_3d ( points , values ): \"\"\" regular grid integration, 3D \"\"\" # volume per cell v = np . diff ( points ) v = v [:, None , None ] * v [ None ,:, None ] * v [ None , None ,:] # weight per cell w = values [: - 1 ] + values [ 1 :] w = w [:, : - 1 ] + w [:, 1 :] w = w [:, :, : - 1 ] + w [:, :, 1 :] w = w / 8 return np . sum ( w * v ) rgrid_integrate_nd ( points , values ) Integrate over n dimensions as linear polynomials on a grid points -- cartesian coordinates of gridpoints values -- values of integrand at gridpoints Integral of linearly interpolated integrand Source code in braketlab/braketlab.py def rgrid_integrate_nd ( points , values ): \"\"\" Integrate over n dimensions as linear polynomials on a grid Keyword arguments: points -- cartesian coordinates of gridpoints values -- values of integrand at gridpoints Returns: Integral of linearly interpolated integrand \"\"\" points = np . diff ( points ) w = \"\" for i in range ( len ( values . shape )): cycle = \"\" for j in range ( len ( values . shape )): if j == i : cycle += \":,\" else : cycle += \"None,\" w += \"points[ %s ] * \" % cycle [: - 1 ] v = eval ( w [: - 2 ]) w = values wd = 1 for i in range ( len ( values . shape )): w = eval ( \"w[ %s :-1] + w[ %s 1:]\" % ( i * \":,\" , i * \":,\" )) wd *= 2 return np . sum ( v * w / wd ) show ( * p , * , t = None ) all-purpose vector visualization Example usage to show the vectors as an image a = ket( ... ) b = ket( ... ) show(a, b) Source code in braketlab/braketlab.py def show ( * p , t = None ): \"\"\" all-purpose vector visualization Example usage to show the vectors as an image a = ket( ... ) b = ket( ... ) show(a, b) \"\"\" mpfig = False mv = 1 for i in list ( p ): spe = i . get_ket_sympy_expression () if type ( spe ) in [ np . array , list , np . ndarray ]: # 1d vector if not mpfig : mpfig = True plt . figure ( figsize = ( 6 , 6 )) vec_R2 = i . coefficients [ 0 ] * i . basis [ 0 ] + i . coefficients [ 1 ] * i . basis [ 1 ] plt . plot ([ 0 , vec_R2 [ 0 ]], [ 0 , vec_R2 [ 1 ]], \"-\" ) plt . plot ([ vec_R2 [ 0 ]], [ vec_R2 [ 1 ]], \"o\" , color = ( 0 , 0 , 0 )) plt . text ( vec_R2 [ 0 ] + .1 , vec_R2 [ 1 ], \" %s \" % i . __name__ ) mv = max ( mv , max ( vec_R2 [ 1 ], vec_R2 [ 0 ]) ) else : vars = list ( spe . free_symbols ) nd = len ( vars ) Nx = 200 x = np . linspace ( - 8 , 8 , 200 ) mv = 8 if nd == 1 : if not mpfig : mpfig = True plt . figure ( figsize = ( 6 , 6 )) plt . plot ( x , i ( x ) , label = i . __name__ ) mpfig = True if nd == 2 : if not mpfig : mpfig = True plt . figure ( figsize = ( 6 , 6 )) plt . contour ( x , x , i ( x [:, None ], x [ None ,:])) if nd == 3 : cube , cm , cmax , cmin = get_cubefile ( i ) v = py3Dmol . view () #cm = cube.mean() offs = cmax * .05 bins = np . linspace ( cm - offs , cm + offs , 2 ) for i in range ( len ( bins )): di = int (( 255 * i / len ( bins ))) v . addVolumetricData ( cube , \"cube\" , { 'isoval' : bins [ i ], 'color' : '# %02x%02x%02x ' % ( 255 - di , di , di ), 'opacity' : 1.0 }) v . zoomTo () v . show () if mpfig : plt . grid () plt . xlim ( - mv - 1 , mv + 1 ) plt . ylim ( - mv - 1 , mv + 1 ) plt . legend () plt . show () show_old ( * p , * , t = None ) all-purpose vector visualization Example usage to show the vectors as an image a = ket( ... ) b = ket( ... ) plot(a, b) Source code in braketlab/braketlab.py def show_old ( * p , t = None ): \"\"\" all-purpose vector visualization Example usage to show the vectors as an image a = ket( ... ) b = ket( ... ) plot(a, b) \"\"\" plt . figure ( figsize = ( 6 , 6 )) try : Nx = 200 x = np . linspace ( - 8 , 8 , 200 ) Z = np . zeros (( Nx , Nx , 3 ), dtype = float ) colors = np . random . uniform ( 0 , 1 ,( len ( list ( p )), 3 )) for i in list ( p ): try : plt . contour ( x , x , i ( x [:, None ], x [ None ,:])) except : plt . plot ( x , i ( x ) , label = i . __name__ ) plt . grid () plt . legend () #plt.show() except : mv = 1 #plt.figure(figsize = (6,6)) for i in list ( p ): vec_R2 = i . coefficients [ 0 ] * i . basis [ 0 ] + i . coefficients [ 1 ] * i . basis [ 1 ] plt . plot ([ 0 , vec_R2 [ 0 ]], [ 0 , vec_R2 [ 1 ]], \"-\" ) plt . plot ([ vec_R2 [ 0 ]], [ vec_R2 [ 1 ]], \"o\" , color = ( 0 , 0 , 0 )) plt . text ( vec_R2 [ 0 ] + .1 , vec_R2 [ 1 ], \" %s \" % i . __name__ ) mv = max ( mv , max ( vec_R2 [ 1 ], vec_R2 [ 0 ]) ) plt . grid () plt . xlim ( - mv - 1 , mv + 1 ) plt . ylim ( - mv - 1 , mv + 1 ) plt . show () split_variables ( s1 , s2 ) make a product where Source code in braketlab/braketlab.py def split_variables ( s1 , s2 ): \"\"\" make a product where \"\"\" # gather particles in first symbols s1s = get_ordered_symbols ( s1 ) for i in range ( len ( s1s )): s1 = s1 . subs ( s1s [ i ], sp . Symbol ( \"x_{0; %i }\" % i )) s2s = get_ordered_symbols ( s2 ) for i in range ( len ( s2s )): s2 = s2 . subs ( s2s [ i ], sp . Symbol ( \"x_{1; %i }\" % i )) return s1 * s2 , get_ordered_symbols ( s1 * s2 )","title":"braketlab"},{"location":"braketlab-reference/#braketlab-module","text":"","title":"Braketlab module"},{"location":"braketlab-reference/#braketlab.braketlab.basisfunction","text":"","title":"basisfunction"},{"location":"braketlab-reference/#braketlab.braketlab.basisfunction--a-general-class-for-a-basis-function-in-mathbbrn","text":"","title":"A general class for a basis function in \\(\\mathbb{R}^n\\)"},{"location":"braketlab-reference/#braketlab.braketlab.basisfunction--keyword-arguments","text":"Argument Description sympy_expression A sympy expression position assumed center of basis function (defaults to \\(\\mathbf{0}\\) ) name (unused) domain if None, the domain is R^n, if [ [x0, x1], [ y0, y1], ... ] , the domain is finite","title":"Keyword arguments:"},{"location":"braketlab-reference/#braketlab.braketlab.basisfunction--methods","text":"Method Description normalize Perform numerical normalization of self estimate_decay Estimate decay of self, used for importance sampling (currently inactive) get_domain(other) Returns the intersecting domain of two basis functions","title":"Methods"},{"location":"braketlab-reference/#braketlab.braketlab.basisfunction--example-usage","text":"x = sympy.Symbol(\"x\") x2 = basisfunction(x**2) x2.normalize()","title":"Example usage:"},{"location":"braketlab-reference/#braketlab.braketlab.basisfunction.__add__","text":"Returns a basisfunction \\(\\chi_{a+b}(\\mathbf{r})\\) , where \\(\\chi_{a+b}(\\mathbf{r}) = \\chi_a(\\mathbf{r}) + \\chi_b(\\mathbf{r})\\) Source code in braketlab/braketlab.py def __add__ ( self , other ): \"\"\" Returns a basisfunction $\\chi_{a+b}(\\mathbf{r})$, where $\\chi_{a+b}(\\mathbf{r}) = \\chi_a(\\mathbf{r}) + \\chi_b(\\mathbf{r})$ \"\"\" return basisfunction ( self . ket_sympy_expression + other . ket_sympy_expression , position = .5 * ( self . position + other . position ), domain = self . get_domain ( other ))","title":"__add__()"},{"location":"braketlab-reference/#braketlab.braketlab.basisfunction.__call__","text":"Evaluate function in coordinates *r (arbitrary dimensions).","title":"__call__()"},{"location":"braketlab-reference/#braketlab.braketlab.basisfunction.__call__--returns","text":"The basisfunction \\(\\chi\\) evaluated in the coordinates provided in the array(s) *r : \\(\\int_{\\mathbb{R}^n} \\delta(\\mathbf{r} - \\mathbf{r'}) \\chi(\\mathbf{r'}) d\\mathbf{r'}\\) Source code in braketlab/braketlab.py def __call__ ( self , * r ): \"\"\" Evaluate function in coordinates ```*r``` (arbitrary dimensions). ## Returns The basisfunction $\\chi$ evaluated in the coordinates provided in the array(s) ```*r```: $\\int_{\\mathbb{R}^n} \\delta(\\mathbf{r} - \\mathbf{r'}) \\chi(\\mathbf{r'}) d\\mathbf{r'}$ \"\"\" return self . normalization * self . ket_numeric_expression ( * r )","title":"Returns"},{"location":"braketlab-reference/#braketlab.braketlab.basisfunction.__mul__","text":"Returns a basisfunction \\(\\chi_{a*b}(\\mathbf{r})\\) , where \\(\\chi_{a*b}(\\mathbf{r}) = \\chi_a(\\mathbf{r}) \\chi_b(\\mathbf{r})\\) Source code in braketlab/braketlab.py def __mul__ ( self , other ): \"\"\" Returns a basisfunction $\\chi_{a*b}(\\mathbf{r})$, where $\\chi_{a*b}(\\mathbf{r}) = \\chi_a(\\mathbf{r}) \\chi_b(\\mathbf{r})$ \"\"\" return basisfunction ( self . ket_sympy_expression * other . ket_sympy_expression , position = .5 * ( self . position + other . position ), domain = self . get_domain ( other ), name = self . __name__ + other . __name__ )","title":"__mul__()"},{"location":"braketlab-reference/#braketlab.braketlab.basisfunction.__sub__","text":"Returns a basisfunction \\(\\chi_{a-b}(\\mathbf{r})\\) , where \\(\\chi_{a-b}(\\mathbf{r}) = \\chi_a(\\mathbf{r}) - \\chi_b(\\mathbf{r})\\) Source code in braketlab/braketlab.py def __sub__ ( self , other ): \"\"\" Returns a basisfunction $\\chi_{a-b}(\\mathbf{r})$, where $\\chi_{a-b}(\\mathbf{r}) = \\chi_a(\\mathbf{r}) - \\chi_b(\\mathbf{r})$ \"\"\" return basisfunction ( self . ket_sympy_expression - other . ket_sympy_expression , position = .5 * ( self . position + other . position ), domain = self . get_domain ( other ))","title":"__sub__()"},{"location":"braketlab-reference/#braketlab.braketlab.basisfunction.normalize","text":"Set normalization factor \\(N\\) of self ( \\(\\chi\\) ) so that \\(\\langle \\chi \\vert \\chi \\rangle = 1\\) . Source code in braketlab/braketlab.py def normalize ( self , domain = None ): \"\"\" Set normalization factor $N$ of self ($\\chi$) so that $\\langle \\chi \\\\vert \\chi \\\\rangle = 1$. \"\"\" s_12 = inner_product ( self , self ) self . normalization = s_12 **- .5","title":"normalize()"},{"location":"braketlab-reference/#braketlab.braketlab.ket","text":"A class for vectors defined on general vector spaces Author: Audun Skau Hansen (a.s.hansen@kjemi.uio.no)","title":"ket"},{"location":"braketlab-reference/#braketlab.braketlab.ket--keyword-arguments","text":"Method Description generic_input if list or numpy.ndarray: if basis is None, returns a cartesian vector else, assumes input to contain coefficients. If sympy expression, returns ket([1], basis = [basisfunction(generic_input)]) name a string, used for labelling and plotting, visual aids basis a list of basisfunctions position assumed centre of function \\(\\langle \\vert \\hat{\\mathbf{r}} \\vert \\rangle\\) . energy if this is an eigenstate of a Hamiltonian, it's eigenvalue may be fixed at initialization","title":"Keyword arguments:"},{"location":"braketlab-reference/#braketlab.braketlab.ket--operations","text":"For kets B and A and scalar c Operation Description A + B addition A - C subtraction A * c scalar multiplication A / c division by a scalar A * B pointwise product A.bra*B inner product A.bra@B inner product A @ B cartesian product A(x) \\(\\int_R^n \\delta(x - x') f(x') dx'\\) evaluate function at x","title":"Operations"},{"location":"braketlab-reference/#braketlab.braketlab.ket.__init__","text":"","title":"__init__()"},{"location":"braketlab-reference/#braketlab.braketlab.ket.__init__--initialization-of-a-ket","text":"Source code in braketlab/braketlab.py def __init__ ( self , generic_input , name = \"\" , basis = None , position = None , energy = None ): \"\"\" ## Initialization of a ket \"\"\" self . position = position if type ( generic_input ) in [ np . ndarray , list ]: self . coefficients = list ( generic_input ) self . basis = [ i for i in np . eye ( len ( self . coefficients ))] if basis is not None : self . basis = basis else : # assume sympy expression if position is None : position = np . zeros ( len ( generic_input . free_symbols ), dtype = float ) self . coefficients = [ 1.0 ] self . basis = [ basisfunction ( generic_input , position = position )] self . ket_sympy_expression = self . get_ket_sympy_expression () self . bra_sympy_expression = self . get_bra_sympy_expression () if energy is not None : self . energy = energy else : self . energy = [ 0 for i in range ( len ( self . basis ))] self . __name__ = name self . bra_state = False self . a = None","title":"Initialization of a ket"},{"location":"braketlab-reference/#braketlab.braketlab.ket.__matmul__","text":"Inner- and Cartesian products Source code in braketlab/braketlab.py def __matmul__ ( self , other ): \"\"\" Inner- and Cartesian products \"\"\" if type ( other ) in [ float , int ]: return self * other if type ( other ) is ket : if self . bra_state : # Compute inner product: < self | other > metric = np . zeros (( len ( self . basis ), len ( other . basis )), dtype = np . complex ) for i in range ( len ( self . basis )): for j in range ( len ( other . basis )): if type ( self . basis [ i ]) is np . ndarray and type ( other . basis [ j ]) is np . ndarray : metric [ i , j ] = np . dot ( self . basis [ i ], other . basis [ j ]) else : if type ( self . basis [ i ]) is basisfunction : if type ( other . basis [ j ]) is basisfunction : # (basisfunction | basisfunction) metric [ i , j ] = inner_product ( self . basis [ i ], other . basis [ j ]) if other . basis [ j ] is ket : # (basisfunction | ket ) metric [ i , j ] = ket ([ 1.0 ], basis = [ self . basis [ i ]]) . bra @other . basis [ j ] else : if type ( other . basis [ j ]) is basisfunction : # ( ket | basisfunction ) metric [ i , j ] = self . basis [ i ] . bra @ket ([ 1.0 ], basis = [ other . basis [ j ]]) else : # ( ket | ket ) metric [ i , j ] = self . basis [ i ] . bra @other . basis [ j ] if np . linalg . norm ( metric . imag ) <= 1e-10 : metric = metric . real return np . array ( self . coefficients ) . T . dot ( metric . dot ( np . array ( other . coefficients ))) else : if type ( other ) is ket : if other . bra_state : return outerprod ( self , other ) else : new_coefficients = [] new_basis = [] variable_identities = [] #for potential two-body interactions for i in range ( len ( self . basis )): for j in range ( len ( other . basis )): #bij, sep = split_variables(self.basis[i].ket_sympy_expression, other.basis[j].ket_sympy_expression) bij , sep = relabel_direct ( self . basis [ i ] . ket_sympy_expression , other . basis [ j ] . ket_sympy_expression ) #bij = ket(bij) bij = basisfunction ( bij ) #, position = other.basis[j].position) bij . position = np . append ( self . basis [ i ] . position , other . basis [ j ] . position ) new_basis . append ( bij ) new_coefficients . append ( self . coefficients [ i ] * other . coefficients [ j ]) variable_identities . append ( sep ) ret = ket ( new_coefficients , basis = new_basis ) ret . flatten () ret . __name__ = self . __name__ + other . __name__ ret . variable_identities = variable_identities return ret","title":"__matmul__()"},{"location":"braketlab-reference/#braketlab.braketlab.ket.flatten","text":"Remove redundancies in the expansion of self Source code in braketlab/braketlab.py def flatten ( self ): \"\"\" Remove redundancies in the expansion of self \"\"\" new_coefficients = [] new_basis = [] new_energies = [] found = [] for i in range ( len ( self . basis )): if i not in found : new_coefficients . append ( self . coefficients [ i ]) new_basis . append ( self . basis [ i ]) new_energies . append ( self . energy [ i ]) for j in range ( i + 1 , len ( self . basis )): if type ( self . basis [ i ]) is np . ndarray : if type ( self . basis [ j ]) is np . ndarray : if np . all ( self . basis [ i ] == self . basis [ j ]): new_coefficients [ i ] += self . coefficients [ j ] found . append ( j ) else : if self . basis [ i ] . ket_sympy_expression == self . basis [ j ] . ket_sympy_expression : if np . all ( self . basis [ i ] . position == self . basis [ j ] . position ): new_coefficients [ i ] += self . coefficients [ j ] found . append ( j ) self . basis = new_basis self . coefficients = new_coefficients self . energy = new_energies","title":"flatten()"},{"location":"braketlab-reference/#braketlab.braketlab.ket.measure","text":"Make a mesaurement of the observable (hermitian operator) Measures by default the continuous distribution as defined by self.bra*self Source code in braketlab/braketlab.py def measure ( self , observable = None , repetitions = 1 ): \"\"\" Make a mesaurement of the observable (hermitian operator) Measures by default the continuous distribution as defined by self.bra*self \"\"\" if observable is None : # Measure position P = self . get_bra_sympy_expression () * self . get_ket_sympy_expression () symbols = get_ordered_symbols ( P ) P = sp . lambdify ( symbols , P , \"numpy\" ) nd = len ( symbols ) sig = .1 #variance of initial distribution r = np . random . multivariate_normal ( np . zeros ( nd ), sig * np . eye ( nd ), repetitions ) # Metropolis-Hastings for i in range ( 1000 ): dr = np . random . multivariate_normal ( np . zeros ( nd ), 0.01 * sig * np . eye ( nd ), repetitions ) accept = P ( r + dr ) / P ( r ) > np . random . uniform ( 0 , 1 , nd ) r [ accept ] += dr [ accept ] return r else : #assert(False), \"Arbitrary measurements not yet implemented\" # get coefficients P = np . zeros ( len ( observable . eigenstates ), dtype = float ) for i in range ( len ( observable . eigenstates )): P [ i ] = ( observable . eigenstates [ i ] . bra @self ) ** 2 distribution = discrete_metropolis_hastings ( P , n_samples = repetitions ) return observable . eigenvalues [ distribution ]","title":"measure()"},{"location":"braketlab-reference/#braketlab.braketlab.operator","text":"Parent class for operators","title":"operator"},{"location":"braketlab-reference/#braketlab.braketlab.operator_expression","text":"","title":"operator_expression"},{"location":"braketlab-reference/#braketlab.braketlab.operator_expression--a-class-for-algebraic-operator-manipulations","text":"instantiate with a list of list of operators","title":"A class for algebraic operator manipulations"},{"location":"braketlab-reference/#braketlab.braketlab.operator_expression--example","text":"operator([[a, b], [c,d]], [1,2]]) = 1*ab + 2*cd","title":"Example"},{"location":"braketlab-reference/#braketlab.braketlab.operator_expression.__add__","text":"","title":"__add__()"},{"location":"braketlab-reference/#braketlab.braketlab.operator_expression.__add__--operator-addition","text":"Source code in braketlab/braketlab.py def __add__ ( self , other ): \"\"\" # Operator addition \"\"\" new_ops = self . ops + other . ops new_coeffs = self . coefficients + other . coefficients return operator_expression ( new_ops , new_coeffs ) . flatten ()","title":"Operator addition"},{"location":"braketlab-reference/#braketlab.braketlab.operator_expression.__mul__","text":"","title":"__mul__()"},{"location":"braketlab-reference/#braketlab.braketlab.operator_expression.__mul__--operator-multiplication","text":"Source code in braketlab/braketlab.py def __mul__ ( self , other ): \"\"\" # Operator multiplication \"\"\" if type ( other ) is operator : new_ops = [] for i in self . ops : for j in other . ops : new_ops . append ( i + j ) return operator ( new_ops ) . flatten () else : return self . apply ( other )","title":"Operator multiplication"},{"location":"braketlab-reference/#braketlab.braketlab.operator_expression.__sub__","text":"","title":"__sub__()"},{"location":"braketlab-reference/#braketlab.braketlab.operator_expression.__sub__--operator-subtraction","text":"Source code in braketlab/braketlab.py def __sub__ ( self , other ): \"\"\" # Operator subtraction \"\"\" new_ops = self . ops + other . ops new_coeffs = self . coefficients + [ - 1 * i for i in other . coefficients ] return operator_expression ( new_ops , new_coeffs ) . flatten ()","title":"Operator subtraction"},{"location":"braketlab-reference/#braketlab.braketlab.operator_expression.apply","text":"","title":"apply()"},{"location":"braketlab-reference/#braketlab.braketlab.operator_expression.apply--apply-operator-to-ket","text":"$\\hat{\\Omega} ert a angle = ert a' angle $","title":"Apply operator to ket"},{"location":"braketlab-reference/#braketlab.braketlab.operator_expression.apply--returns","text":"A new ket Source code in braketlab/braketlab.py def apply ( self , other_ket ): \"\"\" # Apply operator to ket $\\hat{\\Omega} \\vert a \\rangle = \\vert a' \\rangle $ ## Returns A new ket \"\"\" ret = 0 for i in range ( len ( self . ops )): ret_term = other_ket * 1 for j in range ( len ( self . ops [ i ])): ret_term = self . ops [ i ][ - j ] * ret_term if i == 0 : ret = ret_term else : ret = ret + ret_term return ret","title":"Returns"},{"location":"braketlab-reference/#braketlab.braketlab.operator_expression.flatten","text":"","title":"flatten()"},{"location":"braketlab-reference/#braketlab.braketlab.operator_expression.flatten--remove-redundant-terms","text":"Source code in braketlab/braketlab.py def flatten ( self ): \"\"\" # Remove redundant terms \"\"\" new_ops = [] new_coeffs = [] found = [] for i in range ( len ( self . ops )): if i not in found : new_ops . append ( self . ops [ i ]) new_coeffs . append ( 1 ) for j in range ( i + 1 , len ( self . ops )): if self . ops [ i ] == self . ops [ j ]: print ( \"flatten:\" , i , j , self . ops [ i ], self . ops [ j ]) #self.coefficients[i] += 1 found . append ( j ) new_coeffs [ - 1 ] += self . coefficients [ j ] return operator_expression ( new_ops , new_coeffs )","title":"Remove redundant terms"},{"location":"braketlab-reference/#braketlab.braketlab.apply_twobody_operator","text":"Generate the sympy expression sympy_expression / | x_p1 - x_p2 | Source code in braketlab/braketlab.py def apply_twobody_operator ( sympy_expression , p1 , p2 ): \"\"\" Generate the sympy expression sympy_expression / | x_p1 - x_p2 | \"\"\" return sympy_expression / get_twobody_denominator ( sympy_expression , p1 , p2 )","title":"apply_twobody_operator()"},{"location":"braketlab-reference/#braketlab.braketlab.compose_basis","text":"generate a list of basis functions corresponding to the AO-basis (same ordering and so on) Source code in braketlab/braketlab.py def compose_basis ( p ): \"\"\" generate a list of basis functions corresponding to the AO-basis (same ordering and so on) \"\"\" basis = [] for charge in np . arange ( p . charges . shape [ 0 ]): atomic_number = p . charges [ charge ] atom = np . argwhere ( p . atomic_numbers == atomic_number )[ 0 , 0 ] #index of basis function pos = p . atoms [ charge ] for shell in np . arange ( len ( p . basis_set [ atom ])): for contracted in np . arange ( len ( p . basis_set [ atom ][ shell ])): W = np . array ( p . basis_set [ atom ][ shell ][ contracted ]) w = W [:, 1 ] a = W [:, 0 ] if shell == 1 : for m in np . array ([ 1 , - 1 , 0 ]): basis . append ( basis_function ([ shell , m , a , w ], basis_type = \"cgto\" , domain = [[ - 8 , 8 ],[ - 8 , 8 ],[ - 8 , 8 ]], position = pos )) else : for m in np . arange ( - shell , shell + 1 ): basis . append ( basis_function ([ shell , m , a , w ], basis_type = \"cgto\" , domain = [[ - 8 , 8 ],[ - 8 , 8 ],[ - 8 , 8 ]], position = pos )) return basis","title":"compose_basis()"},{"location":"braketlab-reference/#braketlab.braketlab.construct_basis","text":"Build basis from prism object Source code in braketlab/braketlab.py def construct_basis ( p ): \"\"\" Build basis from prism object \"\"\" basis = [] for atom , pos in zip ( p . basis_set , p . atoms ): for shell in atom : for contracted in shell : contracted = np . array ( contracted ) l = int ( contracted [ 0 , 2 ]) a = contracted [:, 0 ] w = contracted [:, 1 ] for m in range ( - l , l + 1 ): bf = w [ 0 ] * get_solid_harmonic_gaussian ( a [ 0 ], l , m , position = [ 0 , 0 , 0 ]) for weights in range ( 1 , len ( w )): bf += w [ i ] * get_solid_harmonic_gaussian ( a [ i ], l , m , position = [ 0 , 0 , 0 ]) #get_solid_harmonic_gaussian(a,l,m, position = [0,0,0]) basis . append ( bf ) return basis","title":"construct_basis()"},{"location":"braketlab-reference/#braketlab.braketlab.discrete_metropolis_hastings","text":"Perform a random walk in the discrete distribution P (array) Source code in braketlab/braketlab.py def discrete_metropolis_hastings ( P , n_samples = 10000 , n_iterations = 10000 , stepsize = None ): \"\"\" Perform a random walk in the discrete distribution P (array) \"\"\" #ensure normality n = np . sum ( P ) Px = interp1d ( np . linspace ( 0 , 1 , len ( P )), P / n ) x = np . random . uniform ( 0 , 1 , n_samples ) if stepsize is None : #set stepsize proportional to discretization stepsize = .5 * len ( P ) **- 1 print ( \"stepsize:\" , stepsize ) for i in range ( n_iterations ): dx = np . random . normal ( 0 , stepsize , n_samples ) xdx = x + dx # periodic boundaries xdx [ xdx < 0 ] += 1 xdx [ xdx > 1 ] -= 1 accept = Px ( xdx ) / Px ( x ) > np . random . uniform ( 0 , 1 , n_samples ) x [ accept ] = xdx [ accept ] return np . array ( x * len ( P ), dtype = int )","title":"discrete_metropolis_hastings()"},{"location":"braketlab-reference/#braketlab.braketlab.eri_mci","text":"Electron repulsion integral estimate using zero-variance Monte Carlo Source code in braketlab/braketlab.py def eri_mci ( phi_p , phi_q , phi_r , phi_s , pp = np . array ([ 0 , 0 , 0 ]), pq = np . array ([ 0 , 0 , 0 ]), pr = np . array ([ 0 , 0 , 0 ]), ps = np . array ([ 0 , 0 , 0 ]), N_samples = 1000000 , sigma = .5 , Pr = np . array ([ 0 , 0 , 0 ]), Qr = np . array ([ 0 , 0 , 0 ]), zeta = 1 , eta = 1 , auto = False , control_variate = lambda x1 , x2 , x3 , x4 , x5 , x6 : 0 ): \"\"\" Electron repulsion integral estimate using zero-variance Monte Carlo \"\"\" x = np . random . multivariate_normal ([ 0 , 0 , 0 , 0 , 0 , 0 ], np . eye ( 6 ) * sigma , N_samples ) P = multivariate_normal ( mean = [ 0 , 0 , 0 , 0 , 0 , 0 ], cov = np . eye ( 6 ) * sigma ) . pdf if auto : # estimate mean and variance of orbitals X , Y , Z = np . random . uniform ( - 5 , 5 ,( 3 , 10000 )) P_1 = phi_p ( X , Y , Z ) * phi_q ( X , Y , Z ) P_2 = phi_r ( X , Y , Z ) * phi_s ( X , Y , Z ) Pr [ 0 ] = np . mean ( P_1 ** 2 * X ) Pr [ 1 ] = np . mean ( P_1 ** 2 * Y ) Pr [ 2 ] = np . mean ( P_1 ** 2 * Z ) Qr [ 0 ] = np . mean ( P_2 ** 2 * X ) Qr [ 1 ] = np . mean ( P_2 ** 2 * Y ) Qr [ 2 ] = np . mean ( P_2 ** 2 * Z ) integrand = lambda * R , \\ phi_p = phi_p , \\ phi_q = phi_q , \\ phi_r = phi_r , \\ phi_s = phi_s , \\ rp = pp , rq = pq , rr = pq , rs = ps : \\ phi_p ( R [ 0 ] - rp [ 0 ], R [ 1 ] - rp [ 1 ], R [ 2 ] - rp [ 2 ]) * \\ phi_q ( R [ 0 ] - rq [ 0 ], R [ 1 ] - rq [ 1 ], R [ 2 ] - rq [ 2 ]) * \\ phi_r ( R [ 3 ] - rr [ 0 ], R [ 4 ] - rr [ 1 ], R [ 5 ] - rr [ 2 ]) * \\ phi_s ( R [ 3 ] - rs [ 0 ], R [ 4 ] - rs [ 1 ], R [ 5 ] - rs [ 2 ]) if control_variate == \"spline\" : control_variate , I0 , t = get_control_variate ( integrand , loc = np . array ([ 0 , 0 , 0 , 0 , 0 , 0 ]), a = .6 , tmin = 1e-5 , extent = 6 , grid = 11 ) u1 = x [:, : 3 ] * zeta **- .5 + Pr [:] u2 = x [:, 3 :] * eta **- .5 + Qr [:] r12 = np . sqrt ( np . sum ( ( u1 - u2 ) ** 2 , axis = 1 )) return np . mean (( phi_p ( u1 [:, 0 ] - pp [ 0 ], u1 [:, 1 ] - pp [ 1 ], u1 [:, 2 ] - pp [ 2 ]) * phi_q ( u1 [:, 0 ] - pq [ 0 ], u1 [:, 1 ] - pq [ 1 ], u1 [:, 2 ] - pq [ 2 ]) * phi_r ( u2 [:, 0 ] - pr [ 0 ], u2 [:, 1 ] - pr [ 1 ], u2 [:, 2 ] - pr [ 2 ]) * phi_s ( u2 [:, 0 ] - ps [ 0 ], u2 [:, 1 ] - ps [ 1 ], u2 [:, 2 ] - ps [ 2 ]) - control_variate ( u1 [:, 0 ], u1 [:, 1 ], u1 [:, 2 ], u2 [:, 0 ], u2 [:, 1 ], u2 [:, 2 ]) ) / ( P ( x ) * r12 ) ) * ( zeta * eta ) **- 1.5","title":"eri_mci()"},{"location":"braketlab-reference/#braketlab.braketlab.get_control_variate","text":"Generate an nd interpolated control variate returns RegularGridInterpolator, definite integral on mesh, mesh points Keyword arguments integrand -- an evaluateable function loc -- position offset for integrand a -- grid density decay, tmin -- extent -- grid -- number of grid points Source code in braketlab/braketlab.py def get_control_variate ( integrand , loc , a = .6 , tmin = 1e-5 , extent = 6 , grid = 101 ): \"\"\" Generate an nd interpolated control variate returns RegularGridInterpolator, definite integral on mesh, mesh points Keyword arguments integrand -- an evaluateable function loc -- position offset for integrand a -- grid density decay, tmin -- extent -- grid -- number of grid points \"\"\" t = np . linspace ( tmin , extent ** a , grid ) ** ( a **- 1 ) t = np . append ( - t [:: - 1 ], t ) R_ = np . ones (( loc . shape [ 0 ], t . shape [ 0 ])) * t [ None ,:] R = np . meshgrid ( * ( R_ - loc [:, None ]), indexing = 'ij' , sparse = True ) data = integrand ( * R ) # Integrate I0 = rgrid_integrate_nd ( t , data ) #return RegularGridInterpolator(R_, data, bounds_error = False, fill_value = 0), I0, t return RegularGridInterpolator ( R_ - loc [:, None ], data , bounds_error = False , fill_value = 0 ), I0 , t","title":"get_control_variate()"},{"location":"braketlab-reference/#braketlab.braketlab.get_twobody_denominator","text":"For a sympy_expression of arbitrary dimensionality, generate the coulomb operator 1/sqrt( r_{p1, p2} ) assuming that the symbols are of the form \"x_{pn, x_i}\" where x_i is the cartesian vector component Source code in braketlab/braketlab.py def get_twobody_denominator ( sympy_expression , p1 , p2 ): \"\"\" For a sympy_expression of arbitrary dimensionality, generate the coulomb operator 1/sqrt( r_{p1, p2} ) assuming that the symbols are of the form \"x_{pn, x_i}\" where x_i is the cartesian vector component \"\"\" mex , n = map_expression ( sympy_expression , p1 , p2 ) denom = 0 for i in range ( n ): denom += ( mex [ 0 , i ] - mex [ 1 , i ]) ** 2 return sp . sqrt ( denom )","title":"get_twobody_denominator()"},{"location":"braketlab-reference/#braketlab.braketlab.inner_product","text":"Computes the inner product < b1 | b2 >, where bn are instances of basisfunction b1, b2 -- basisfunction objects operator -- obsolete n_samples -- number of Monte Carlo samples grid -- number of grid-points in every direction for the spline control variate The inner product as a float Source code in braketlab/braketlab.py @lru_cache ( maxsize = 100 ) def inner_product ( b1 , b2 , operator = None , n_samples = int ( 1e6 ), grid = 101 , sigma = None ): \"\"\" Computes the inner product < b1 | b2 >, where bn are instances of basisfunction Keyword arguments: b1, b2 -- basisfunction objects operator -- obsolete n_samples -- number of Monte Carlo samples grid -- number of grid-points in every direction for the spline control variate Returns: The inner product as a float \"\"\" ri = b1 . position * 0 rj = b2 . position * 0 integrand = lambda * R , \\ f1 = b1 . bra_numeric_expression , \\ f2 = b2 . ket_numeric_expression , \\ ri = ri , rj = rj : \\ f1 ( * np . array ([ R [ i ] - ri [ i ] for i in range ( len ( ri ))])) * f2 ( * np . array ([ R [ i ] - rj [ i ] for i in range ( len ( rj ))])) #f1(*np.array([R[i] - ri[i] for i in range(len(ri))]))*f2(*np.array([R[i] - rj[i] for i in range(len(rj))])) variables_b1 = b1 . bra_sympy_expression . free_symbols variables_b2 = b2 . ket_sympy_expression . free_symbols if len ( variables_b1 ) == 1 and len ( variables_b2 ) == 1 : return integrate . quad ( integrand , - 10 , 10 )[ 0 ] else : ai , aj = b1 . decay , b2 . decay ri , rj = b1 . position , b2 . position R = ( ai * ri + aj * rj ) / ( ai + aj ) if sigma is None : sigma = .5 * ( ai + aj ) #print(\"R, sigma:\", R, sigma) return onebody ( integrand , np . ones ( len ( R )) * sigma , R , n_samples ) #, control_variate = \"spline\", grid = grid)","title":"inner_product()"},{"location":"braketlab-reference/#braketlab.braketlab.map_expression","text":"Map out the free symbols of sympy_expressions in order to determine z[p, x] where p = [0,1] is particle x1 and x2, while x is their cartesian component Source code in braketlab/braketlab.py def map_expression ( sympy_expression , x1 = 0 , x2 = 1 ): \"\"\" Map out the free symbols of sympy_expressions in order to determine z[p, x] where p = [0,1] is particle x1 and x2, while x is their cartesian component \"\"\" map_ = { x1 : 0 , x2 : 1 } s = sympy_expression . free_symbols n = int ( len ( s ) / 2 ) z = np . zeros (( 2 , n ), dtype = object ) for i in s : j , k = parse_symbol ( i ) #particle, coordinate z [ map_ [ j ], k ] = i return z , n","title":"map_expression()"},{"location":"braketlab-reference/#braketlab.braketlab.metropolis_hastings","text":"Metropolis-Hastings random walk in the function f Source code in braketlab/braketlab.py def metropolis_hastings ( f , N , x0 , a ): \"\"\" Metropolis-Hastings random walk in the function f \"\"\" x = np . random . multivariate_normal ( x0 , a , N ) for i in range ( 1000 ): dx = np . random . multivariate_normal ( x0 , a * 0.01 , N ) accept = f ( x + dx ) / f ( x ) > np . random . uniform ( 0 , 1 , N ) x [ accept ] += dx [ accept ] return x","title":"metropolis_hastings()"},{"location":"braketlab-reference/#braketlab.braketlab.onebody","text":"Monte Carlo (MC) estimate of integral integrand -- evaluatable function sigma -- standard deviation of normal distribution used for importance sampling loc -- centre used for control variate and importance sampling n_sampes -- number of MC-samples control_variate -- evaluatable function grid -- sampling density of spline control variate I0 -- analytical integral of control variate Estimated integral (float) Source code in braketlab/braketlab.py def onebody ( integrand , sigma , loc , n_samples , control_variate = lambda * r : 0 , grid = 101 , I0 = 0 ): \"\"\" Monte Carlo (MC) estimate of integral Keyword arguments: integrand -- evaluatable function sigma -- standard deviation of normal distribution used for importance sampling loc -- centre used for control variate and importance sampling n_sampes -- number of MC-samples control_variate -- evaluatable function grid -- sampling density of spline control variate I0 -- analytical integral of control variate returns: Estimated integral (float) \"\"\" if control_variate == \"spline\" : control_variate , I0 , t = get_control_variate ( integrand , loc , a = .6 , tmin = 1e-5 , extent = 6 , grid = grid ) #R = np.random.multivariate_normal(loc, np.eye(len(loc))*sigma, n_samples) #R = np.random.Generator.multivariate_normal(loc, np.eye(len(loc))*sigma, size=n_samples) R = np . random . default_rng () . multivariate_normal ( loc , np . eye ( len ( loc )) * sigma , n_samples ) P = multivariate_normal ( mean = loc , cov = np . eye ( len ( loc )) * sigma ) . pdf ( R ) return I0 + np . mean (( integrand ( * R . T ) - control_variate ( R )) * P **- 1 )","title":"onebody()"},{"location":"braketlab-reference/#braketlab.braketlab.parse_symbol","text":"Parse a symbol of the form x_{i;j} Return a list [i,j] Source code in braketlab/braketlab.py def parse_symbol ( x ): \"\"\" Parse a symbol of the form x_{i;j} Return a list [i,j] \"\"\" strspl = str ( x ) . split ( \"{\" )[ 1 ] . split ( \"}\" )[ 0 ] . split ( \";\" ) return [ int ( i ) for i in strspl ]","title":"parse_symbol()"},{"location":"braketlab-reference/#braketlab.braketlab.rgrid_integrate_3d","text":"regular grid integration, 3D Source code in braketlab/braketlab.py def rgrid_integrate_3d ( points , values ): \"\"\" regular grid integration, 3D \"\"\" # volume per cell v = np . diff ( points ) v = v [:, None , None ] * v [ None ,:, None ] * v [ None , None ,:] # weight per cell w = values [: - 1 ] + values [ 1 :] w = w [:, : - 1 ] + w [:, 1 :] w = w [:, :, : - 1 ] + w [:, :, 1 :] w = w / 8 return np . sum ( w * v )","title":"rgrid_integrate_3d()"},{"location":"braketlab-reference/#braketlab.braketlab.rgrid_integrate_nd","text":"Integrate over n dimensions as linear polynomials on a grid points -- cartesian coordinates of gridpoints values -- values of integrand at gridpoints Integral of linearly interpolated integrand Source code in braketlab/braketlab.py def rgrid_integrate_nd ( points , values ): \"\"\" Integrate over n dimensions as linear polynomials on a grid Keyword arguments: points -- cartesian coordinates of gridpoints values -- values of integrand at gridpoints Returns: Integral of linearly interpolated integrand \"\"\" points = np . diff ( points ) w = \"\" for i in range ( len ( values . shape )): cycle = \"\" for j in range ( len ( values . shape )): if j == i : cycle += \":,\" else : cycle += \"None,\" w += \"points[ %s ] * \" % cycle [: - 1 ] v = eval ( w [: - 2 ]) w = values wd = 1 for i in range ( len ( values . shape )): w = eval ( \"w[ %s :-1] + w[ %s 1:]\" % ( i * \":,\" , i * \":,\" )) wd *= 2 return np . sum ( v * w / wd )","title":"rgrid_integrate_nd()"},{"location":"braketlab-reference/#braketlab.braketlab.show","text":"all-purpose vector visualization Example usage to show the vectors as an image a = ket( ... ) b = ket( ... ) show(a, b) Source code in braketlab/braketlab.py def show ( * p , t = None ): \"\"\" all-purpose vector visualization Example usage to show the vectors as an image a = ket( ... ) b = ket( ... ) show(a, b) \"\"\" mpfig = False mv = 1 for i in list ( p ): spe = i . get_ket_sympy_expression () if type ( spe ) in [ np . array , list , np . ndarray ]: # 1d vector if not mpfig : mpfig = True plt . figure ( figsize = ( 6 , 6 )) vec_R2 = i . coefficients [ 0 ] * i . basis [ 0 ] + i . coefficients [ 1 ] * i . basis [ 1 ] plt . plot ([ 0 , vec_R2 [ 0 ]], [ 0 , vec_R2 [ 1 ]], \"-\" ) plt . plot ([ vec_R2 [ 0 ]], [ vec_R2 [ 1 ]], \"o\" , color = ( 0 , 0 , 0 )) plt . text ( vec_R2 [ 0 ] + .1 , vec_R2 [ 1 ], \" %s \" % i . __name__ ) mv = max ( mv , max ( vec_R2 [ 1 ], vec_R2 [ 0 ]) ) else : vars = list ( spe . free_symbols ) nd = len ( vars ) Nx = 200 x = np . linspace ( - 8 , 8 , 200 ) mv = 8 if nd == 1 : if not mpfig : mpfig = True plt . figure ( figsize = ( 6 , 6 )) plt . plot ( x , i ( x ) , label = i . __name__ ) mpfig = True if nd == 2 : if not mpfig : mpfig = True plt . figure ( figsize = ( 6 , 6 )) plt . contour ( x , x , i ( x [:, None ], x [ None ,:])) if nd == 3 : cube , cm , cmax , cmin = get_cubefile ( i ) v = py3Dmol . view () #cm = cube.mean() offs = cmax * .05 bins = np . linspace ( cm - offs , cm + offs , 2 ) for i in range ( len ( bins )): di = int (( 255 * i / len ( bins ))) v . addVolumetricData ( cube , \"cube\" , { 'isoval' : bins [ i ], 'color' : '# %02x%02x%02x ' % ( 255 - di , di , di ), 'opacity' : 1.0 }) v . zoomTo () v . show () if mpfig : plt . grid () plt . xlim ( - mv - 1 , mv + 1 ) plt . ylim ( - mv - 1 , mv + 1 ) plt . legend () plt . show ()","title":"show()"},{"location":"braketlab-reference/#braketlab.braketlab.show_old","text":"all-purpose vector visualization Example usage to show the vectors as an image a = ket( ... ) b = ket( ... ) plot(a, b) Source code in braketlab/braketlab.py def show_old ( * p , t = None ): \"\"\" all-purpose vector visualization Example usage to show the vectors as an image a = ket( ... ) b = ket( ... ) plot(a, b) \"\"\" plt . figure ( figsize = ( 6 , 6 )) try : Nx = 200 x = np . linspace ( - 8 , 8 , 200 ) Z = np . zeros (( Nx , Nx , 3 ), dtype = float ) colors = np . random . uniform ( 0 , 1 ,( len ( list ( p )), 3 )) for i in list ( p ): try : plt . contour ( x , x , i ( x [:, None ], x [ None ,:])) except : plt . plot ( x , i ( x ) , label = i . __name__ ) plt . grid () plt . legend () #plt.show() except : mv = 1 #plt.figure(figsize = (6,6)) for i in list ( p ): vec_R2 = i . coefficients [ 0 ] * i . basis [ 0 ] + i . coefficients [ 1 ] * i . basis [ 1 ] plt . plot ([ 0 , vec_R2 [ 0 ]], [ 0 , vec_R2 [ 1 ]], \"-\" ) plt . plot ([ vec_R2 [ 0 ]], [ vec_R2 [ 1 ]], \"o\" , color = ( 0 , 0 , 0 )) plt . text ( vec_R2 [ 0 ] + .1 , vec_R2 [ 1 ], \" %s \" % i . __name__ ) mv = max ( mv , max ( vec_R2 [ 1 ], vec_R2 [ 0 ]) ) plt . grid () plt . xlim ( - mv - 1 , mv + 1 ) plt . ylim ( - mv - 1 , mv + 1 ) plt . show ()","title":"show_old()"},{"location":"braketlab-reference/#braketlab.braketlab.split_variables","text":"make a product where Source code in braketlab/braketlab.py def split_variables ( s1 , s2 ): \"\"\" make a product where \"\"\" # gather particles in first symbols s1s = get_ordered_symbols ( s1 ) for i in range ( len ( s1s )): s1 = s1 . subs ( s1s [ i ], sp . Symbol ( \"x_{0; %i }\" % i )) s2s = get_ordered_symbols ( s2 ) for i in range ( len ( s2s )): s2 = s2 . subs ( s2s [ i ], sp . Symbol ( \"x_{1; %i }\" % i )) return s1 * s2 , get_ordered_symbols ( s1 * s2 )","title":"split_variables()"},{"location":"harmonic_oscillator-reference/","text":"Harmonic Oscillator module factorial ( n ) return n! Source code in braketlab/harmonic_oscillator.py def factorial ( n ): \"\"\" return n! \"\"\" return np . prod ( np . arange ( n ) + 1 ) hermite ( f , z , n ) The n-th order Hermite polynomial Source code in braketlab/harmonic_oscillator.py def hermite ( f , z , n ): \"\"\" The n-th order Hermite polynomial \"\"\" return ( - 1 ) ** n * sp . exp ( f ** 2 ) * sp . diff ( sp . exp ( - f ** 2 ), z , n ) psi_ho ( n , omega = 1 , mass = 1 , hbar = 1 , time = False ) The n-th normalized harmonic oscillator eigenfunction (stationary state if time = false) Source code in braketlab/harmonic_oscillator.py def psi_ho ( n , omega = 1 , mass = 1 , hbar = 1 , time = False ): \"\"\" The n-th normalized harmonic oscillator eigenfunction (stationary state if time = false) \"\"\" norm_factor = 1 / np . sqrt ( factorial ( n ) * 2 ** n ) x , t = sp . symbols ( \"x t\" ) prefactor = ( mass * omega / ( np . pi * hbar )) ** .25 core = sp . exp ( - mass * omega * x ** 2 / ( 2 * hbar )) psi = hermite ( sp . sqrt ( mass * omega / hbar ) * x , x , n ) time_dependence = 1 if time : time_dependence = sp . exp ( - sp . I * omega * ( n + .5 ) * t ) return norm_factor * prefactor * core * psi #*time_dependence","title":"Harmonic Oscillator module"},{"location":"harmonic_oscillator-reference/#harmonic-oscillator-module","text":"","title":"Harmonic Oscillator module"},{"location":"harmonic_oscillator-reference/#braketlab.harmonic_oscillator.factorial","text":"return n! Source code in braketlab/harmonic_oscillator.py def factorial ( n ): \"\"\" return n! \"\"\" return np . prod ( np . arange ( n ) + 1 )","title":"factorial()"},{"location":"harmonic_oscillator-reference/#braketlab.harmonic_oscillator.hermite","text":"The n-th order Hermite polynomial Source code in braketlab/harmonic_oscillator.py def hermite ( f , z , n ): \"\"\" The n-th order Hermite polynomial \"\"\" return ( - 1 ) ** n * sp . exp ( f ** 2 ) * sp . diff ( sp . exp ( - f ** 2 ), z , n )","title":"hermite()"},{"location":"harmonic_oscillator-reference/#braketlab.harmonic_oscillator.psi_ho","text":"The n-th normalized harmonic oscillator eigenfunction (stationary state if time = false) Source code in braketlab/harmonic_oscillator.py def psi_ho ( n , omega = 1 , mass = 1 , hbar = 1 , time = False ): \"\"\" The n-th normalized harmonic oscillator eigenfunction (stationary state if time = false) \"\"\" norm_factor = 1 / np . sqrt ( factorial ( n ) * 2 ** n ) x , t = sp . symbols ( \"x t\" ) prefactor = ( mass * omega / ( np . pi * hbar )) ** .25 core = sp . exp ( - mass * omega * x ** 2 / ( 2 * hbar )) psi = hermite ( sp . sqrt ( mass * omega / hbar ) * x , x , n ) time_dependence = 1 if time : time_dependence = sp . exp ( - sp . I * omega * ( n + .5 ) * t ) return norm_factor * prefactor * core * psi #*time_dependence","title":"psi_ho()"},{"location":"hydrogen-reference/","text":"Hydrogen module associated_laguerre_polynomial ( x , i , alpha ) Associated Laguerre polynomial constructed by recursion (see https://en.wikipedia.org/wiki/Laguerre_polynomials#Generalized_Laguerre_polynomials) Source code in braketlab/hydrogen.py def associated_laguerre_polynomial ( x , i , alpha ): \"\"\" Associated Laguerre polynomial constructed by recursion (see https://en.wikipedia.org/wiki/Laguerre_polynomials#Generalized_Laguerre_polynomials) \"\"\" rr = sp . symbols ( \"r_1\" ) return sp . exp ( x ) * x **- alpha / factorial ( i ) * ( sp . diff ( sp . exp ( - rr ) * rr ** ( i + alpha ), rr , i ) . subs ( rr , x )) legendre_polynomial ( x , n ) Returns the Legendre polynomial, as Source code in braketlab/hydrogen.py def legendre_polynomial ( x , n ): \"\"\" Returns the Legendre polynomial, as \"\"\" return 1 / ( 2 ** n * factorial ( n )) * sp . diff (( x ** 2 - 1 ) ** n , x , n )","title":"hydrogen"},{"location":"hydrogen-reference/#hydrogen-module","text":"","title":"Hydrogen module"},{"location":"hydrogen-reference/#braketlab.hydrogen.associated_laguerre_polynomial","text":"Associated Laguerre polynomial constructed by recursion (see https://en.wikipedia.org/wiki/Laguerre_polynomials#Generalized_Laguerre_polynomials) Source code in braketlab/hydrogen.py def associated_laguerre_polynomial ( x , i , alpha ): \"\"\" Associated Laguerre polynomial constructed by recursion (see https://en.wikipedia.org/wiki/Laguerre_polynomials#Generalized_Laguerre_polynomials) \"\"\" rr = sp . symbols ( \"r_1\" ) return sp . exp ( x ) * x **- alpha / factorial ( i ) * ( sp . diff ( sp . exp ( - rr ) * rr ** ( i + alpha ), rr , i ) . subs ( rr , x ))","title":"associated_laguerre_polynomial()"},{"location":"hydrogen-reference/#braketlab.hydrogen.legendre_polynomial","text":"Returns the Legendre polynomial, as Source code in braketlab/hydrogen.py def legendre_polynomial ( x , n ): \"\"\" Returns the Legendre polynomial, as \"\"\" return 1 / ( 2 ** n * factorial ( n )) * sp . diff (( x ** 2 - 1 ) ** n , x , n )","title":"legendre_polynomial()"},{"location":"solid_harmonics-reference/","text":"Solid Harmonics module contracted_norm ( a , w , l ) Compute normalization factor of contracted basis function Source code in braketlab/solid_harmonics.py def contracted_norm ( a , w , l ): \"\"\" Compute normalization factor of contracted basis function \"\"\" return np . sum ( w [:, None ] * w [ None ,:] * ( np . sqrt ( 4 * a [:, None ] * a [ None ,:]) / ( a [:, None ] + a [ None ,:])) ** ( 1.5 + l )) f ( m ) factorial m! Source code in braketlab/solid_harmonics.py def f ( m ): \"\"\" factorial m! \"\"\" return np . max ([ np . prod ( np . arange ( m ) + 1 ), 1 ]) get_Nao ( a , l , m ) return normalized AO in sympy-format a = exponent l = angular quantum number m = magnetic quantum number Source code in braketlab/solid_harmonics.py def get_Nao ( a , l , m ): \"\"\" return normalized AO in sympy-format a = exponent l = angular quantum number m = magnetic quantum number \"\"\" return get_ao ( a , l , m ) * get_Npi ( a , l ) * norm_extra ( l ) get_Nao_at ( pos , a , l , m ) return normalized AO in sympy-format a = exponent l = angular quantum number m = magnetic quantum number Source code in braketlab/solid_harmonics.py def get_Nao_at ( pos , a , l , m ): \"\"\" return normalized AO in sympy-format a = exponent l = angular quantum number m = magnetic quantum number \"\"\" return get_ao_at ( pos , a , l , m ) * get_Npi ( a , l ) * norm_extra ( l ) get_Nao_lambda ( a , l , m ) return a normalized solid harmonic gaussian in numpy lambda format, for convenient evaluation. Note that every function is centered in (0,0,0) translations should be performed retrospectively Source code in braketlab/solid_harmonics.py def get_Nao_lambda ( a , l , m ): \"\"\" return a normalized solid harmonic gaussian in numpy lambda format, for convenient evaluation. Note that every function is centered in (0,0,0) translations should be performed retrospectively \"\"\" x , y , z = sp . symbols ( \"x y z\" ) return sp . lambdify ([ x , y , z ], get_Nao ( a , l , m ), \"numpy\" ) get_Npi ( a_i , l ) Returns the normalization prefactor for S_lm(a_i, r) a_i = exponent l = angular quantum number Source code in braketlab/solid_harmonics.py def get_Npi ( a_i , l ): \"\"\" Returns the normalization prefactor for S_lm(a_i, r) a_i = exponent l = angular quantum number \"\"\" return ( 2 * sp . pi ) ** ( - .75 ) * ( 4 * a_i ) ** ( 0.75 + l / 2.0 ) get_Slm ( l , m ) return the sympy real solid harmonic gaussian S_{lm}(r) as presented in table 6.3 of Helgaker, J\u00f8rgensen and Olsen (page 211) Source code in braketlab/solid_harmonics.py def get_Slm ( l , m ): \"\"\" return the sympy real solid harmonic gaussian S_{lm}(r) as presented in table 6.3 of Helgaker, J\u00f8rgensen and Olsen (page 211) \"\"\" x , y , z = sp . symbols ( \"x y z\" ) r = sp . sqrt ( x ** 2 + y ** 2 + z ** 2 ) assert ( l < 5 ), \"Only l<=4 permitted\" assert ( l >= 0 ), \"Invalid l value\" assert ( np . abs ( m ) <= l ), \"Invalid m value\" if l == 0 : if m == 0 : return x ** 0 if l == 1 : if m == 1 : return x if m == 0 : return z if m ==- 1 : return y if l == 2 : if m == 2 : return ( x ** 2 - y ** 2 ) * sp . sqrt ( 3.0 ) / 2.0 if m == 1 : return x * z * sp . sqrt ( 3.0 ) if m == 0 : return ( 3 * z ** 2 - r ** 2 ) / 2.0 if m ==- 1 : return y * z * sp . sqrt ( 3.0 ) if m ==- 2 : return x * y * sp . sqrt ( 3.0 ) if l == 3 : if m == 3 : return x * ( x ** 2 - 3 * y ** 2 ) * sp . sqrt ( 5 / 2.0 ) / 2 if m == 2 : return z * ( x ** 2 - y ** 2 ) * sp . sqrt ( 15 ) / 2 if m == 1 : return x * ( 5 * z ** 2 - r ** 2 ) * sp . sqrt ( 3 / 2.0 ) / 2 if m == 0 : return z * ( 5 * z ** 2 - 3 * r ** 2 ) / 2 if m ==- 1 : return y * ( 5 * z ** 2 - r ** 2 ) * sp . sqrt ( 3 / 2.0 ) / 2 if m ==- 2 : return x * y * z * sp . sqrt ( 15 ) if m ==- 3 : return x * y * z * sp . sqrt ( 15 ) if l == 4 : if m == 4 : return ( x ** 4 - 6 * x ** 2 * y ** 2 + y ** 4 ) * sp . sqrt ( 35 ) / 8 if m == 3 : return ( x ** 2 - 3 * y ** 2 ) * x * z * sp . sqrt ( 35 / 2.0 ) / 2 if m == 2 : return ( 7 * z ** 2 - r ** 2 ) * ( x ** 2 - y ** 2 ) * sp . sqrt ( 5 ) / 4 if m == 1 : return ( 7 * z ** 2 - 3 * r ** 2 ) * x * z * sp . sqrt ( 5 / 2.0 ) / 2 if m == 0 : return ( 35 * z ** 4 - 30 * z ** 2 * r ** 2 + 3 * r ** 4 ) / 8 if m ==- 1 : return ( 7 * z ** 2 - 3 * r ** 2 ) * y * z * sp . sqrt ( 5 / 2.0 ) / 2 if m ==- 2 : return ( 7 * z ** 2 - r ** 2 ) * x * y * sp . sqrt ( 5 ) / 2 if m ==- 3 : return ( 3 * x ** 2 - y ** 2 ) * y * z * sp . sqrt ( 35 / 2.0 ) / 2 if m ==- 4 : return ( x ** 2 - y ** 2 ) * x * y * sp . sqrt ( 35 ) / 2 get_ao ( a , l , m ) return unnormalized solid harmonic gaussian for quantum numbers l, m a = exponent Source code in braketlab/solid_harmonics.py def get_ao ( a , l , m ): \"\"\" return unnormalized solid harmonic gaussian for quantum numbers l, m a = exponent \"\"\" x , y , z = sp . symbols ( \"x y z\" ) slm = get_Slm ( l , m ) return slm * sp . exp ( - a * ( x ** 2 + y ** 2 + z ** 2 )) get_ao_at ( pos , a , l , m ) return unnormalized solid harmonic gaussian for quantum numbers l, m a = exponent Source code in braketlab/solid_harmonics.py def get_ao_at ( pos , a , l , m ): \"\"\" return unnormalized solid harmonic gaussian for quantum numbers l, m a = exponent \"\"\" x , y , z = sp . symbols ( \"x y z\" ) slm = get_Slm ( l , m ) chi = slm * sp . exp ( - a * ( x ** 2 + y ** 2 + z ** 2 )) chi = chi . subs ( x , x - pos [ 0 ]) chi = chi . subs ( y , y - pos [ 1 ]) chi = chi . subs ( z , z - pos [ 2 ]) return chi get_contracted ( a , w , l , m , representation = 'numeric' ) Generates Solid Harmonic Gaussian lambda functions a = exponent Source code in braketlab/solid_harmonics.py def get_contracted ( a , w , l , m , representation = \"numeric\" ): \"\"\" Generates Solid Harmonic Gaussian lambda functions a = exponent \"\"\" S = contracted_norm ( a , w , l ) CGO = 0 for i in np . arange ( a . shape [ 0 ]): CGO += w [ i ] * get_Nao ( a [ i ], l , m ) / np . sqrt ( S ) if representation is \"numeric\" : x , y , z = sp . symbols ( \"x y z\" ) return sp . lambdify ([ x , y , z ], CGO , \"numpy\" ) if representation is \"sympy\" : return CGO get_contracted_at ( pos , a , w , l , m ) Generates Solid Harmonic Gaussian lambda functions a = exponents Source code in braketlab/solid_harmonics.py def get_contracted_at ( pos , a , w , l , m ): \"\"\" Generates Solid Harmonic Gaussian lambda functions a = exponents \"\"\" S = contracted_norm ( a , w , l ) CGO = 0 for i in np . arange ( a . shape [ 0 ]): CGO += w [ i ] * get_Nao_at ( pos , a [ i ], l , m ) / np . sqrt ( S ) #print(CGO) x , y , z = sp . symbols ( \"x y z\" ) return CGO #sp.lambdify([x,y,z], c*CGO, \"numpy\") get_contracted_sympy ( a , w , l , m ) Generates Solid Harmonic Gaussian lambda functions a = exponents Source code in braketlab/solid_harmonics.py def get_contracted_sympy ( a , w , l , m ): \"\"\" Generates Solid Harmonic Gaussian lambda functions a = exponents \"\"\" S = contracted_norm ( a , w , l ) CGO = 0 for i in np . arange ( a . shape [ 0 ]): CGO += w [ i ] * get_Nao ( a [ i ], l , m ) / np . sqrt ( S ) return CGO norm_extra ( l ) Factor required that is not accounted for in eq. 3.3 in LSDalton manual Source code in braketlab/solid_harmonics.py def norm_extra ( l ): \"\"\" Factor required that is _not_ accounted for in eq. 3.3 in LSDalton manual \"\"\" return ( np . array ([ 1 , 1 , 3 , 15 , 105 ]) **- .5 )[ l ]","title":"solid_harmonics"},{"location":"solid_harmonics-reference/#solid-harmonics-module","text":"","title":"Solid Harmonics module"},{"location":"solid_harmonics-reference/#braketlab.solid_harmonics.contracted_norm","text":"Compute normalization factor of contracted basis function Source code in braketlab/solid_harmonics.py def contracted_norm ( a , w , l ): \"\"\" Compute normalization factor of contracted basis function \"\"\" return np . sum ( w [:, None ] * w [ None ,:] * ( np . sqrt ( 4 * a [:, None ] * a [ None ,:]) / ( a [:, None ] + a [ None ,:])) ** ( 1.5 + l ))","title":"contracted_norm()"},{"location":"solid_harmonics-reference/#braketlab.solid_harmonics.f","text":"factorial m! Source code in braketlab/solid_harmonics.py def f ( m ): \"\"\" factorial m! \"\"\" return np . max ([ np . prod ( np . arange ( m ) + 1 ), 1 ])","title":"f()"},{"location":"solid_harmonics-reference/#braketlab.solid_harmonics.get_Nao","text":"return normalized AO in sympy-format a = exponent l = angular quantum number m = magnetic quantum number Source code in braketlab/solid_harmonics.py def get_Nao ( a , l , m ): \"\"\" return normalized AO in sympy-format a = exponent l = angular quantum number m = magnetic quantum number \"\"\" return get_ao ( a , l , m ) * get_Npi ( a , l ) * norm_extra ( l )","title":"get_Nao()"},{"location":"solid_harmonics-reference/#braketlab.solid_harmonics.get_Nao_at","text":"return normalized AO in sympy-format a = exponent l = angular quantum number m = magnetic quantum number Source code in braketlab/solid_harmonics.py def get_Nao_at ( pos , a , l , m ): \"\"\" return normalized AO in sympy-format a = exponent l = angular quantum number m = magnetic quantum number \"\"\" return get_ao_at ( pos , a , l , m ) * get_Npi ( a , l ) * norm_extra ( l )","title":"get_Nao_at()"},{"location":"solid_harmonics-reference/#braketlab.solid_harmonics.get_Nao_lambda","text":"return a normalized solid harmonic gaussian in numpy lambda format, for convenient evaluation. Note that every function is centered in (0,0,0) translations should be performed retrospectively Source code in braketlab/solid_harmonics.py def get_Nao_lambda ( a , l , m ): \"\"\" return a normalized solid harmonic gaussian in numpy lambda format, for convenient evaluation. Note that every function is centered in (0,0,0) translations should be performed retrospectively \"\"\" x , y , z = sp . symbols ( \"x y z\" ) return sp . lambdify ([ x , y , z ], get_Nao ( a , l , m ), \"numpy\" )","title":"get_Nao_lambda()"},{"location":"solid_harmonics-reference/#braketlab.solid_harmonics.get_Npi","text":"Returns the normalization prefactor for S_lm(a_i, r) a_i = exponent l = angular quantum number Source code in braketlab/solid_harmonics.py def get_Npi ( a_i , l ): \"\"\" Returns the normalization prefactor for S_lm(a_i, r) a_i = exponent l = angular quantum number \"\"\" return ( 2 * sp . pi ) ** ( - .75 ) * ( 4 * a_i ) ** ( 0.75 + l / 2.0 )","title":"get_Npi()"},{"location":"solid_harmonics-reference/#braketlab.solid_harmonics.get_Slm","text":"return the sympy real solid harmonic gaussian S_{lm}(r) as presented in table 6.3 of Helgaker, J\u00f8rgensen and Olsen (page 211) Source code in braketlab/solid_harmonics.py def get_Slm ( l , m ): \"\"\" return the sympy real solid harmonic gaussian S_{lm}(r) as presented in table 6.3 of Helgaker, J\u00f8rgensen and Olsen (page 211) \"\"\" x , y , z = sp . symbols ( \"x y z\" ) r = sp . sqrt ( x ** 2 + y ** 2 + z ** 2 ) assert ( l < 5 ), \"Only l<=4 permitted\" assert ( l >= 0 ), \"Invalid l value\" assert ( np . abs ( m ) <= l ), \"Invalid m value\" if l == 0 : if m == 0 : return x ** 0 if l == 1 : if m == 1 : return x if m == 0 : return z if m ==- 1 : return y if l == 2 : if m == 2 : return ( x ** 2 - y ** 2 ) * sp . sqrt ( 3.0 ) / 2.0 if m == 1 : return x * z * sp . sqrt ( 3.0 ) if m == 0 : return ( 3 * z ** 2 - r ** 2 ) / 2.0 if m ==- 1 : return y * z * sp . sqrt ( 3.0 ) if m ==- 2 : return x * y * sp . sqrt ( 3.0 ) if l == 3 : if m == 3 : return x * ( x ** 2 - 3 * y ** 2 ) * sp . sqrt ( 5 / 2.0 ) / 2 if m == 2 : return z * ( x ** 2 - y ** 2 ) * sp . sqrt ( 15 ) / 2 if m == 1 : return x * ( 5 * z ** 2 - r ** 2 ) * sp . sqrt ( 3 / 2.0 ) / 2 if m == 0 : return z * ( 5 * z ** 2 - 3 * r ** 2 ) / 2 if m ==- 1 : return y * ( 5 * z ** 2 - r ** 2 ) * sp . sqrt ( 3 / 2.0 ) / 2 if m ==- 2 : return x * y * z * sp . sqrt ( 15 ) if m ==- 3 : return x * y * z * sp . sqrt ( 15 ) if l == 4 : if m == 4 : return ( x ** 4 - 6 * x ** 2 * y ** 2 + y ** 4 ) * sp . sqrt ( 35 ) / 8 if m == 3 : return ( x ** 2 - 3 * y ** 2 ) * x * z * sp . sqrt ( 35 / 2.0 ) / 2 if m == 2 : return ( 7 * z ** 2 - r ** 2 ) * ( x ** 2 - y ** 2 ) * sp . sqrt ( 5 ) / 4 if m == 1 : return ( 7 * z ** 2 - 3 * r ** 2 ) * x * z * sp . sqrt ( 5 / 2.0 ) / 2 if m == 0 : return ( 35 * z ** 4 - 30 * z ** 2 * r ** 2 + 3 * r ** 4 ) / 8 if m ==- 1 : return ( 7 * z ** 2 - 3 * r ** 2 ) * y * z * sp . sqrt ( 5 / 2.0 ) / 2 if m ==- 2 : return ( 7 * z ** 2 - r ** 2 ) * x * y * sp . sqrt ( 5 ) / 2 if m ==- 3 : return ( 3 * x ** 2 - y ** 2 ) * y * z * sp . sqrt ( 35 / 2.0 ) / 2 if m ==- 4 : return ( x ** 2 - y ** 2 ) * x * y * sp . sqrt ( 35 ) / 2","title":"get_Slm()"},{"location":"solid_harmonics-reference/#braketlab.solid_harmonics.get_ao","text":"return unnormalized solid harmonic gaussian for quantum numbers l, m a = exponent Source code in braketlab/solid_harmonics.py def get_ao ( a , l , m ): \"\"\" return unnormalized solid harmonic gaussian for quantum numbers l, m a = exponent \"\"\" x , y , z = sp . symbols ( \"x y z\" ) slm = get_Slm ( l , m ) return slm * sp . exp ( - a * ( x ** 2 + y ** 2 + z ** 2 ))","title":"get_ao()"},{"location":"solid_harmonics-reference/#braketlab.solid_harmonics.get_ao_at","text":"return unnormalized solid harmonic gaussian for quantum numbers l, m a = exponent Source code in braketlab/solid_harmonics.py def get_ao_at ( pos , a , l , m ): \"\"\" return unnormalized solid harmonic gaussian for quantum numbers l, m a = exponent \"\"\" x , y , z = sp . symbols ( \"x y z\" ) slm = get_Slm ( l , m ) chi = slm * sp . exp ( - a * ( x ** 2 + y ** 2 + z ** 2 )) chi = chi . subs ( x , x - pos [ 0 ]) chi = chi . subs ( y , y - pos [ 1 ]) chi = chi . subs ( z , z - pos [ 2 ]) return chi","title":"get_ao_at()"},{"location":"solid_harmonics-reference/#braketlab.solid_harmonics.get_contracted","text":"Generates Solid Harmonic Gaussian lambda functions a = exponent Source code in braketlab/solid_harmonics.py def get_contracted ( a , w , l , m , representation = \"numeric\" ): \"\"\" Generates Solid Harmonic Gaussian lambda functions a = exponent \"\"\" S = contracted_norm ( a , w , l ) CGO = 0 for i in np . arange ( a . shape [ 0 ]): CGO += w [ i ] * get_Nao ( a [ i ], l , m ) / np . sqrt ( S ) if representation is \"numeric\" : x , y , z = sp . symbols ( \"x y z\" ) return sp . lambdify ([ x , y , z ], CGO , \"numpy\" ) if representation is \"sympy\" : return CGO","title":"get_contracted()"},{"location":"solid_harmonics-reference/#braketlab.solid_harmonics.get_contracted_at","text":"Generates Solid Harmonic Gaussian lambda functions a = exponents Source code in braketlab/solid_harmonics.py def get_contracted_at ( pos , a , w , l , m ): \"\"\" Generates Solid Harmonic Gaussian lambda functions a = exponents \"\"\" S = contracted_norm ( a , w , l ) CGO = 0 for i in np . arange ( a . shape [ 0 ]): CGO += w [ i ] * get_Nao_at ( pos , a [ i ], l , m ) / np . sqrt ( S ) #print(CGO) x , y , z = sp . symbols ( \"x y z\" ) return CGO #sp.lambdify([x,y,z], c*CGO, \"numpy\")","title":"get_contracted_at()"},{"location":"solid_harmonics-reference/#braketlab.solid_harmonics.get_contracted_sympy","text":"Generates Solid Harmonic Gaussian lambda functions a = exponents Source code in braketlab/solid_harmonics.py def get_contracted_sympy ( a , w , l , m ): \"\"\" Generates Solid Harmonic Gaussian lambda functions a = exponents \"\"\" S = contracted_norm ( a , w , l ) CGO = 0 for i in np . arange ( a . shape [ 0 ]): CGO += w [ i ] * get_Nao ( a [ i ], l , m ) / np . sqrt ( S ) return CGO","title":"get_contracted_sympy()"},{"location":"solid_harmonics-reference/#braketlab.solid_harmonics.norm_extra","text":"Factor required that is not accounted for in eq. 3.3 in LSDalton manual Source code in braketlab/solid_harmonics.py def norm_extra ( l ): \"\"\" Factor required that is _not_ accounted for in eq. 3.3 in LSDalton manual \"\"\" return ( np . array ([ 1 , 1 , 3 , 15 , 105 ]) **- .5 )[ l ]","title":"norm_extra()"}]}